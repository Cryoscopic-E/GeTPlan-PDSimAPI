// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: unified_planning.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = Google.Protobuf;
using pbc = Google.Protobuf.Collections;
using pbr = Google.Protobuf.Reflection;
using scg = System.Collections.Generic;
namespace Proto
{


    /// <summary>Holder for reflection information generated from unified_planning.proto</summary>
    public static partial class UnifiedPlanningReflection
    {

        #region Descriptor
        /// <summary>File descriptor for unified_planning.proto</summary>
        public static pbr::FileDescriptor Descriptor
        {
            get { return descriptor; }
        }
        private static pbr::FileDescriptor descriptor;

        static UnifiedPlanningReflection()
        {
            byte[] descriptorData = System.Convert.FromBase64String(
                string.Concat(
                  "ChZ1bmlmaWVkX3BsYW5uaW5nLnByb3RvImkKCkV4cHJlc3Npb24SEwoEYXRv",
                  "bRgBIAEoCzIFLkF0b20SGQoEbGlzdBgCIAMoCzILLkV4cHJlc3Npb24SDAoE",
                  "dHlwZRgDIAEoCRIdCgRraW5kGAQgASgOMg8uRXhwcmVzc2lvbktpbmQiXAoE",
                  "QXRvbRIQCgZzeW1ib2wYASABKAlIABINCgNpbnQYAiABKANIABIVCgRyZWFs",
                  "GAMgASgLMgUuUmVhbEgAEhEKB2Jvb2xlYW4YBCABKAhIAEIJCgdjb250ZW50",
                  "Ii4KBFJlYWwSEQoJbnVtZXJhdG9yGAEgASgDEhMKC2Rlbm9taW5hdG9yGAIg",
                  "ASgDIjkKD1R5cGVEZWNsYXJhdGlvbhIRCgl0eXBlX25hbWUYASABKAkSEwoL",
                  "cGFyZW50X3R5cGUYAiABKAkiJwoJUGFyYW1ldGVyEgwKBG5hbWUYASABKAkS",
                  "DAoEdHlwZRgCIAEoCSJuCgZGbHVlbnQSDAoEbmFtZRgBIAEoCRISCgp2YWx1",
                  "ZV90eXBlGAIgASgJEh4KCnBhcmFtZXRlcnMYAyADKAsyCi5QYXJhbWV0ZXIS",
                  "IgoNZGVmYXVsdF92YWx1ZRgEIAEoCzILLkV4cHJlc3Npb24iLwoRT2JqZWN0",
                  "RGVjbGFyYXRpb24SDAoEbmFtZRgBIAEoCRIMCgR0eXBlGAIgASgJIuoBChBF",
                  "ZmZlY3RFeHByZXNzaW9uEioKBGtpbmQYASABKA4yHC5FZmZlY3RFeHByZXNz",
                  "aW9uLkVmZmVjdEtpbmQSGwoGZmx1ZW50GAIgASgLMgsuRXhwcmVzc2lvbhIa",
                  "CgV2YWx1ZRgDIAEoCzILLkV4cHJlc3Npb24SHgoJY29uZGl0aW9uGAQgASgL",
                  "MgsuRXhwcmVzc2lvbhIbCgZmb3JhbGwYBSADKAsyCy5FeHByZXNzaW9uIjQK",
                  "CkVmZmVjdEtpbmQSCgoGQVNTSUdOEAASDAoISU5DUkVBU0UQARIMCghERUNS",
                  "RUFTRRACIk0KBkVmZmVjdBIhCgZlZmZlY3QYASABKAsyES5FZmZlY3RFeHBy",
                  "ZXNzaW9uEiAKD29jY3VycmVuY2VfdGltZRgCIAEoCzIHLlRpbWluZyJDCglD",
                  "b25kaXRpb24SGQoEY29uZBgBIAEoCzILLkV4cHJlc3Npb24SGwoEc3BhbhgC",
                  "IAEoCzINLlRpbWVJbnRlcnZhbCKNAQoGQWN0aW9uEgwKBG5hbWUYASABKAkS",
                  "HgoKcGFyYW1ldGVycxgCIAMoCzIKLlBhcmFtZXRlchIbCghkdXJhdGlvbhgD",
                  "IAEoCzIJLkR1cmF0aW9uEh4KCmNvbmRpdGlvbnMYBCADKAsyCi5Db25kaXRp",
                  "b24SGAoHZWZmZWN0cxgFIAMoCzIHLkVmZmVjdCKQAQoJVGltZXBvaW50EiYK",
                  "BGtpbmQYASABKA4yGC5UaW1lcG9pbnQuVGltZXBvaW50S2luZBIUCgxjb250",
                  "YWluZXJfaWQYAiABKAkiRQoNVGltZXBvaW50S2luZBIQCgxHTE9CQUxfU1RB",
                  "UlQQABIOCgpHTE9CQUxfRU5EEAESCQoFU1RBUlQQAhIHCgNFTkQQAyI9CgZU",
                  "aW1pbmcSHQoJdGltZXBvaW50GAEgASgLMgouVGltZXBvaW50EhQKBWRlbGF5",
                  "GAIgASgLMgUuUmVhbCJvCghJbnRlcnZhbBIUCgxpc19sZWZ0X29wZW4YASAB",
                  "KAgSGgoFbG93ZXIYAiABKAsyCy5FeHByZXNzaW9uEhUKDWlzX3JpZ2h0X29w",
                  "ZW4YAyABKAgSGgoFdXBwZXIYBCABKAsyCy5FeHByZXNzaW9uImsKDFRpbWVJ",
                  "bnRlcnZhbBIUCgxpc19sZWZ0X29wZW4YASABKAgSFgoFbG93ZXIYAiABKAsy",
                  "By5UaW1pbmcSFQoNaXNfcmlnaHRfb3BlbhgDIAEoCBIWCgV1cHBlchgEIAEo",
                  "CzIHLlRpbWluZyI1CghEdXJhdGlvbhIpChZjb250cm9sbGFibGVfaW5fYm91",
                  "bmRzGAEgASgLMgkuSW50ZXJ2YWwiRwoXQWJzdHJhY3RUYXNrRGVjbGFyYXRp",
                  "b24SDAoEbmFtZRgBIAEoCRIeCgpwYXJhbWV0ZXJzGAIgAygLMgouUGFyYW1l",
                  "dGVyIkYKBFRhc2sSCgoCaWQYASABKAkSEQoJdGFza19uYW1lGAIgASgJEh8K",
                  "CnBhcmFtZXRlcnMYAyADKAsyCy5FeHByZXNzaW9uIq8BCgZNZXRob2QSDAoE",
                  "bmFtZRgBIAEoCRIeCgpwYXJhbWV0ZXJzGAIgAygLMgouUGFyYW1ldGVyEhwK",
                  "DWFjaGlldmVkX3Rhc2sYAyABKAsyBS5UYXNrEhcKCHN1YnRhc2tzGAQgAygL",
                  "MgUuVGFzaxIgCgtjb25zdHJhaW50cxgFIAMoCzILLkV4cHJlc3Npb24SHgoK",
                  "Y29uZGl0aW9ucxgGIAMoCzIKLkNvbmRpdGlvbiJnCgtUYXNrTmV0d29yaxId",
                  "Cgl2YXJpYWJsZXMYASADKAsyCi5QYXJhbWV0ZXISFwoIc3VidGFza3MYAiAD",
                  "KAsyBS5UYXNrEiAKC2NvbnN0cmFpbnRzGAMgAygLMgsuRXhwcmVzc2lvbiKD",
                  "AQoJSGllcmFyY2h5EjAKDmFic3RyYWN0X3Rhc2tzGAEgAygLMhguQWJzdHJh",
                  "Y3RUYXNrRGVjbGFyYXRpb24SGAoHbWV0aG9kcxgCIAMoCzIHLk1ldGhvZBIq",
                  "ChRpbml0aWFsX3Rhc2tfbmV0d29yaxgDIAEoCzIMLlRhc2tOZXR3b3JrIrEB",
                  "CghBY3Rpdml0eRIMCgRuYW1lGAEgASgJEh4KCnBhcmFtZXRlcnMYAiADKAsy",
                  "Ci5QYXJhbWV0ZXISGwoIZHVyYXRpb24YAyABKAsyCS5EdXJhdGlvbhIeCgpj",
                  "b25kaXRpb25zGAQgAygLMgouQ29uZGl0aW9uEhgKB2VmZmVjdHMYBSADKAsy",
                  "By5FZmZlY3QSIAoLY29uc3RyYWludHMYBiADKAsyCy5FeHByZXNzaW9uInUK",
                  "E1NjaGVkdWxpbmdFeHRlbnNpb24SHQoKYWN0aXZpdGllcxgBIAMoCzIJLkFj",
                  "dGl2aXR5Eh0KCXZhcmlhYmxlcxgCIAMoCzIKLlBhcmFtZXRlchIgCgtjb25z",
                  "dHJhaW50cxgFIAMoCzILLkV4cHJlc3Npb24iowEKCFNjaGVkdWxlEhIKCmFj",
                  "dGl2aXRpZXMYASADKAkSQAoUdmFyaWFibGVfYXNzaWdubWVudHMYAiADKAsy",
                  "Ii5TY2hlZHVsZS5WYXJpYWJsZUFzc2lnbm1lbnRzRW50cnkaQQoYVmFyaWFi",
                  "bGVBc3NpZ25tZW50c0VudHJ5EgsKA2tleRgBIAEoCRIUCgV2YWx1ZRgCIAEo",
                  "CzIFLkF0b206AjgBIkAKBEdvYWwSGQoEZ29hbBgBIAEoCzILLkV4cHJlc3Np",
                  "b24SHQoGdGltaW5nGAIgASgLMg0uVGltZUludGVydmFsIlIKC1RpbWVkRWZm",
                  "ZWN0EiEKBmVmZmVjdBgBIAEoCzIRLkVmZmVjdEV4cHJlc3Npb24SIAoPb2Nj",
                  "dXJyZW5jZV90aW1lGAIgASgLMgcuVGltaW5nIkUKCkFzc2lnbm1lbnQSGwoG",
                  "Zmx1ZW50GAEgASgLMgsuRXhwcmVzc2lvbhIaCgV2YWx1ZRgCIAEoCzILLkV4",
                  "cHJlc3Npb24iQgoOR29hbFdpdGhXZWlnaHQSGQoEZ29hbBgBIAEoCzILLkV4",
                  "cHJlc3Npb24SFQoGd2VpZ2h0GAIgASgLMgUuUmVhbCJmChNUaW1lZEdvYWxX",
                  "aXRoV2VpZ2h0EhkKBGdvYWwYASABKAsyCy5FeHByZXNzaW9uEh0KBnRpbWlu",
                  "ZxgCIAEoCzINLlRpbWVJbnRlcnZhbBIVCgZ3ZWlnaHQYAyABKAsyBS5SZWFs",
                  "IpwECgZNZXRyaWMSIAoEa2luZBgBIAEoDjISLk1ldHJpYy5NZXRyaWNLaW5k",
                  "Eh8KCmV4cHJlc3Npb24YAiABKAsyCy5FeHByZXNzaW9uEi4KDGFjdGlvbl9j",
                  "b3N0cxgDIAMoCzIYLk1ldHJpYy5BY3Rpb25Db3N0c0VudHJ5EigKE2RlZmF1",
                  "bHRfYWN0aW9uX2Nvc3QYBCABKAsyCy5FeHByZXNzaW9uEh4KBWdvYWxzGAUg",
                  "AygLMg8uR29hbFdpdGhXZWlnaHQSKQoLdGltZWRfZ29hbHMYBiADKAsyFC5U",
                  "aW1lZEdvYWxXaXRoV2VpZ2h0Gj8KEEFjdGlvbkNvc3RzRW50cnkSCwoDa2V5",
                  "GAEgASgJEhoKBXZhbHVlGAIgASgLMgsuRXhwcmVzc2lvbjoCOAEi6AEKCk1l",
                  "dHJpY0tpbmQSGQoVTUlOSU1JWkVfQUNUSU9OX0NPU1RTEAASIwofTUlOSU1J",
                  "WkVfU0VRVUVOVElBTF9QTEFOX0xFTkdUSBABEhUKEU1JTklNSVpFX01BS0VT",
                  "UEFOEAISJgoiTUlOSU1JWkVfRVhQUkVTU0lPTl9PTl9GSU5BTF9TVEFURRAD",
                  "EiYKIk1BWElNSVpFX0VYUFJFU1NJT05fT05fRklOQUxfU1RBVEUQBBIUChBP",
                  "VkVSU1VCU0NSSVBUSU9OEAUSHQoZVEVNUE9SQUxfT1ZFUlNVQlNDUklQVElP",
                  "ThAGIowECgdQcm9ibGVtEhMKC2RvbWFpbl9uYW1lGAEgASgJEhQKDHByb2Js",
                  "ZW1fbmFtZRgCIAEoCRIfCgV0eXBlcxgDIAMoCzIQLlR5cGVEZWNsYXJhdGlv",
                  "bhIYCgdmbHVlbnRzGAQgAygLMgcuRmx1ZW50EiMKB29iamVjdHMYBSADKAsy",
                  "Ei5PYmplY3REZWNsYXJhdGlvbhIYCgdhY3Rpb25zGAYgAygLMgcuQWN0aW9u",
                  "EiIKDWluaXRpYWxfc3RhdGUYByADKAsyCy5Bc3NpZ25tZW50EiMKDXRpbWVk",
                  "X2VmZmVjdHMYCCADKAsyDC5UaW1lZEVmZmVjdBIUCgVnb2FscxgJIAMoCzIF",
                  "LkdvYWwSGgoIZmVhdHVyZXMYCiADKA4yCC5GZWF0dXJlEhgKB21ldHJpY3MY",
                  "CyADKAsyBy5NZXRyaWMSHQoJaGllcmFyY2h5GAwgASgLMgouSGllcmFyY2h5",
                  "EjIKFHNjaGVkdWxpbmdfZXh0ZW5zaW9uGBEgASgLMhQuU2NoZWR1bGluZ0V4",
                  "dGVuc2lvbhIrChZ0cmFqZWN0b3J5X2NvbnN0cmFpbnRzGA0gAygLMgsuRXhw",
                  "cmVzc2lvbhIVCg1kaXNjcmV0ZV90aW1lGA4gASgIEhgKEHNlbGZfb3Zlcmxh",
                  "cHBpbmcYDyABKAgSFgoHZXBzaWxvbhgQIAEoCzIFLlJlYWwigAEKDkFjdGlv",
                  "bkluc3RhbmNlEgoKAmlkGAEgASgJEhMKC2FjdGlvbl9uYW1lGAIgASgJEhkK",
                  "CnBhcmFtZXRlcnMYAyADKAsyBS5BdG9tEhkKCnN0YXJ0X3RpbWUYBCABKAsy",
                  "BS5SZWFsEhcKCGVuZF90aW1lGAUgASgLMgUuUmVhbCKuAQoOTWV0aG9kSW5z",
                  "dGFuY2USCgoCaWQYASABKAkSEwoLbWV0aG9kX25hbWUYAiABKAkSGQoKcGFy",
                  "YW1ldGVycxgDIAMoCzIFLkF0b20SLwoIc3VidGFza3MYBiADKAsyHS5NZXRo",
                  "b2RJbnN0YW5jZS5TdWJ0YXNrc0VudHJ5Gi8KDVN1YnRhc2tzRW50cnkSCwoD",
                  "a2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKWAQoNUGxhbkhpZXJhcmNo",
                  "eRIxCgpyb290X3Rhc2tzGAEgAygLMh0uUGxhbkhpZXJhcmNoeS5Sb290VGFz",
                  "a3NFbnRyeRIgCgdtZXRob2RzGAIgAygLMg8uTWV0aG9kSW5zdGFuY2UaMAoO",
                  "Um9vdFRhc2tzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4",
                  "ASJoCgRQbGFuEiAKB2FjdGlvbnMYASADKAsyDy5BY3Rpb25JbnN0YW5jZRIh",
                  "CgloaWVyYXJjaHkYAiABKAsyDi5QbGFuSGllcmFyY2h5EhsKCHNjaGVkdWxl",
                  "GAMgASgLMgkuU2NoZWR1bGUigwIKC1BsYW5SZXF1ZXN0EhkKB3Byb2JsZW0Y",
                  "ASABKAsyCC5Qcm9ibGVtEioKD3Jlc29sdXRpb25fbW9kZRgCIAEoDjIRLlBs",
                  "YW5SZXF1ZXN0Lk1vZGUSDwoHdGltZW91dBgDIAEoARI3Cg5lbmdpbmVfb3B0",
                  "aW9ucxgEIAMoCzIfLlBsYW5SZXF1ZXN0LkVuZ2luZU9wdGlvbnNFbnRyeRo0",
                  "ChJFbmdpbmVPcHRpb25zRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIg",
                  "ASgJOgI4ASItCgRNb2RlEg8KC1NBVElTRklBQkxFEAASFAoQU09MVkVEX09Q",
                  "VElNQUxMWRABIkMKEVZhbGlkYXRpb25SZXF1ZXN0EhkKB3Byb2JsZW0YASAB",
                  "KAsyCC5Qcm9ibGVtEhMKBHBsYW4YAiABKAsyBS5QbGFuInsKCkxvZ01lc3Nh",
                  "Z2USIwoFbGV2ZWwYASABKA4yFC5Mb2dNZXNzYWdlLkxvZ0xldmVsEg8KB21l",
                  "c3NhZ2UYAiABKAkiNwoITG9nTGV2ZWwSCQoFREVCVUcQABIICgRJTkZPEAES",
                  "CwoHV0FSTklORxACEgkKBUVSUk9SEAMivwMKFFBsYW5HZW5lcmF0aW9uUmVz",
                  "dWx0EiwKBnN0YXR1cxgBIAEoDjIcLlBsYW5HZW5lcmF0aW9uUmVzdWx0LlN0",
                  "YXR1cxITCgRwbGFuGAIgASgLMgUuUGxhbhIzCgdtZXRyaWNzGAMgAygLMiIu",
                  "UGxhbkdlbmVyYXRpb25SZXN1bHQuTWV0cmljc0VudHJ5EiEKDGxvZ19tZXNz",
                  "YWdlcxgEIAMoCzILLkxvZ01lc3NhZ2USFwoGZW5naW5lGAUgASgLMgcuRW5n",
                  "aW5lGi4KDE1ldHJpY3NFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiAB",
                  "KAk6AjgBIsIBCgZTdGF0dXMSFgoSU09MVkVEX1NBVElTRklDSU5HEAASFAoQ",
                  "U09MVkVEX09QVElNQUxMWRABEhUKEVVOU09MVkFCTEVfUFJPVkVOEAISGwoX",
                  "VU5TT0xWQUJMRV9JTkNPTVBMRVRFTFkQAxILCgdUSU1FT1VUEA0SCgoGTUVN",
                  "T1VUEA4SEgoOSU5URVJOQUxfRVJST1IQDxIXChNVTlNVUFBPUlRFRF9QUk9C",
                  "TEVNEBASEAoMSU5URVJNRURJQVRFEBEiFgoGRW5naW5lEgwKBG5hbWUYASAB",
                  "KAkixwEKEFZhbGlkYXRpb25SZXN1bHQSOAoGc3RhdHVzGAEgASgOMiguVmFs",
                  "aWRhdGlvblJlc3VsdC5WYWxpZGF0aW9uUmVzdWx0U3RhdHVzEiEKDGxvZ19t",
                  "ZXNzYWdlcxgCIAMoCzILLkxvZ01lc3NhZ2USFwoGZW5naW5lGAMgASgLMgcu",
                  "RW5naW5lIj0KFlZhbGlkYXRpb25SZXN1bHRTdGF0dXMSCQoFVkFMSUQQABIL",
                  "CgdJTlZBTElEEAESCwoHVU5LTk9XThACIuUBCg5Db21waWxlclJlc3VsdBIZ",
                  "Cgdwcm9ibGVtGAEgASgLMgguUHJvYmxlbRI3Cg1tYXBfYmFja19wbGFuGAIg",
                  "AygLMiAuQ29tcGlsZXJSZXN1bHQuTWFwQmFja1BsYW5FbnRyeRIhCgxsb2df",
                  "bWVzc2FnZXMYAyADKAsyCy5Mb2dNZXNzYWdlEhcKBmVuZ2luZRgEIAEoCzIH",
                  "LkVuZ2luZRpDChBNYXBCYWNrUGxhbkVudHJ5EgsKA2tleRgBIAEoCRIeCgV2",
                  "YWx1ZRgCIAEoCzIPLkFjdGlvbkluc3RhbmNlOgI4ASqwAQoORXhwcmVzc2lv",
                  "bktpbmQSCwoHVU5LTk9XThAAEgwKCENPTlNUQU5UEAESDQoJUEFSQU1FVEVS",
                  "EAISDAoIVkFSSUFCTEUQBxIRCg1GTFVFTlRfU1lNQk9MEAMSEwoPRlVOQ1RJ",
                  "T05fU1lNQk9MEAQSEgoOU1RBVEVfVkFSSUFCTEUQBRIYChRGVU5DVElPTl9B",
                  "UFBMSUNBVElPThAGEhAKDENPTlRBSU5FUl9JRBAIKrQMCgdGZWF0dXJlEhAK",
                  "DEFDVElPTl9CQVNFRBAAEhAKDEhJRVJBUkNISUNBTBAaEg4KClNDSEVEVUxJ",
                  "TkcQOBIbChdTSU1QTEVfTlVNRVJJQ19QTEFOTklORxAeEhwKGEdFTkVSQUxf",
                  "TlVNRVJJQ19QTEFOTklORxAfEhMKD0NPTlRJTlVPVVNfVElNRRABEhEKDURJ",
                  "U0NSRVRFX1RJTUUQAhInCiNJTlRFUk1FRElBVEVfQ09ORElUSU9OU19BTkRf",
                  "RUZGRUNUUxADEiMKH0VYVEVSTkFMX0NPTkRJVElPTlNfQU5EX0VGRkVDVFMQ",
                  "JxIRCg1USU1FRF9FRkZFQ1RTEAQSDwoLVElNRURfR09BTFMQBRIZChVEVVJB",
                  "VElPTl9JTkVRVUFMSVRJRVMQBhIUChBTRUxGX09WRVJMQVBQSU5HEC8SHwob",
                  "U1RBVElDX0ZMVUVOVFNfSU5fRFVSQVRJT05TEBsSGAoURkxVRU5UU19JTl9E",
                  "VVJBVElPTlMQHBIWChJDT05USU5VT1VTX05VTUJFUlMQBxIUChBESVNDUkVU",
                  "RV9OVU1CRVJTEAgSEQoNQk9VTkRFRF9UWVBFUxAmEhcKE05FR0FUSVZFX0NP",
                  "TkRJVElPTlMQCRIaChZESVNKVU5DVElWRV9DT05ESVRJT05TEAoSDgoKRVFV",
                  "QUxJVElFUxALEhoKFkVYSVNURU5USUFMX0NPTkRJVElPTlMQDBIYChRVTklW",
                  "RVJTQUxfQ09ORElUSU9OUxANEhcKE0NPTkRJVElPTkFMX0VGRkVDVFMQDhIU",
                  "ChBJTkNSRUFTRV9FRkZFQ1RTEA8SFAoQREVDUkVBU0VfRUZGRUNUUxAQEikK",
                  "JVNUQVRJQ19GTFVFTlRTX0lOX0JPT0xFQU5fQVNTSUdOTUVOVFMQKRIpCiVT",
                  "VEFUSUNfRkxVRU5UU19JTl9OVU1FUklDX0FTU0lHTk1FTlRTECoSKAokU1RB",
                  "VElDX0ZMVUVOVFNfSU5fT0JKRUNUX0FTU0lHTk1FTlRTEDkSIgoeRkxVRU5U",
                  "U19JTl9CT09MRUFOX0FTU0lHTk1FTlRTECsSIgoeRkxVRU5UU19JTl9OVU1F",
                  "UklDX0FTU0lHTk1FTlRTECwSIQodRkxVRU5UU19JTl9PQkpFQ1RfQVNTSUdO",
                  "TUVOVFMQOhISCg5GT1JBTExfRUZGRUNUUxA7Eg8KC0ZMQVRfVFlQSU5HEBES",
                  "FwoTSElFUkFSQ0hJQ0FMX1RZUElORxASEhMKD05VTUVSSUNfRkxVRU5UUxAT",
                  "EhIKDk9CSkVDVF9GTFVFTlRTEBQSGgoWQk9PTF9GTFVFTlRfUEFSQU1FVEVS",
                  "UxAyEiEKHUJPVU5ERURfSU5UX0ZMVUVOVF9QQVJBTUVURVJTEDMSGgoWQk9P",
                  "TF9BQ1RJT05fUEFSQU1FVEVSUxA0EiEKHUJPVU5ERURfSU5UX0FDVElPTl9Q",
                  "QVJBTUVURVJTEDUSIwofVU5CT1VOREVEX0lOVF9BQ1RJT05fUEFSQU1FVEVS",
                  "UxA2EhoKFlJFQUxfQUNUSU9OX1BBUkFNRVRFUlMQNxIQCgxBQ1RJT05TX0NP",
                  "U1QQFRIPCgtGSU5BTF9WQUxVRRAWEgwKCE1BS0VTUEFOEBcSDwoLUExBTl9M",
                  "RU5HVEgQGBIUChBPVkVSU1VCU0NSSVBUSU9OEB0SHQoZVEVNUE9SQUxfT1ZF",
                  "UlNVQlNDUklQVElPThAoEiIKHlNUQVRJQ19GTFVFTlRTX0lOX0FDVElPTlNf",
                  "Q09TVBAtEhsKF0ZMVUVOVFNfSU5fQUNUSU9OU19DT1NUEC4SFQoRU0lNVUxB",
                  "VEVEX0VGRkVDVFMQGRIaChZUUkFKRUNUT1JZX0NPTlNUUkFJTlRTEDASFAoQ",
                  "U1RBVEVfSU5WQVJJQU5UUxAxEhgKFE1FVEhPRF9QUkVDT05ESVRJT05TECAS",
                  "HAoYVEFTS19ORVRXT1JLX0NPTlNUUkFJTlRTECESIgoeSU5JVElBTF9UQVNL",
                  "X05FVFdPUktfVkFSSUFCTEVTECISFAoQVEFTS19PUkRFUl9UT1RBTBAjEhYK",
                  "ElRBU0tfT1JERVJfUEFSVElBTBAkEhcKE1RBU0tfT1JERVJfVEVNUE9SQUwQ",
                  "JTLYAQoPVW5pZmllZFBsYW5uaW5nEjQKC3BsYW5Bbnl0aW1lEgwuUGxhblJl",
                  "cXVlc3QaFS5QbGFuR2VuZXJhdGlvblJlc3VsdDABEjIKC3BsYW5PbmVTaG90",
                  "EgwuUGxhblJlcXVlc3QaFS5QbGFuR2VuZXJhdGlvblJlc3VsdBI1Cgx2YWxp",
                  "ZGF0ZVBsYW4SEi5WYWxpZGF0aW9uUmVxdWVzdBoRLlZhbGlkYXRpb25SZXN1",
                  "bHQSJAoHY29tcGlsZRIILlByb2JsZW0aDy5Db21waWxlclJlc3VsdGIGcHJv",
                  "dG8z"));
            descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
                new pbr::FileDescriptor[] { },
                new pbr::GeneratedClrTypeInfo(new[] { typeof(ExpressionKind), typeof(Feature), }, new pbr::GeneratedClrTypeInfo[] {
          new pbr::GeneratedClrTypeInfo(typeof(Expression), Expression.Parser, new[]{ "Atom", "List", "Type", "Kind" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Atom), Atom.Parser, new[]{ "Symbol", "Int", "Real", "Boolean" }, new[]{ "Content" }, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Real), Real.Parser, new[]{ "Numerator", "Denominator" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(TypeDeclaration), TypeDeclaration.Parser, new[]{ "TypeName", "ParentType" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Parameter), Parameter.Parser, new[]{ "Name", "Type" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Fluent), Fluent.Parser, new[]{ "Name", "ValueType", "Parameters", "DefaultValue" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(ObjectDeclaration), ObjectDeclaration.Parser, new[]{ "Name", "Type" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(EffectExpression), EffectExpression.Parser, new[]{ "Kind", "Fluent", "Value", "Condition", "Forall" }, null, new[]{ typeof(EffectExpression.Types.EffectKind) }, null),
          new pbr::GeneratedClrTypeInfo(typeof(Effect), Effect.Parser, new[]{ "Effect_", "OccurrenceTime" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Condition), Condition.Parser, new[]{ "Cond", "Span" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Action), Action.Parser, new[]{ "Name", "Parameters", "Duration", "Conditions", "Effects" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Timepoint), Timepoint.Parser, new[]{ "Kind", "ContainerId" }, null, new[]{ typeof(Timepoint.Types.TimepointKind) }, null),
          new pbr::GeneratedClrTypeInfo(typeof(Timing), Timing.Parser, new[]{ "Timepoint", "Delay" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Interval), Interval.Parser, new[]{ "IsLeftOpen", "Lower", "IsRightOpen", "Upper" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(TimeInterval), TimeInterval.Parser, new[]{ "IsLeftOpen", "Lower", "IsRightOpen", "Upper" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Duration), Duration.Parser, new[]{ "ControllableInBounds" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(AbstractTaskDeclaration), AbstractTaskDeclaration.Parser, new[]{ "Name", "Parameters" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Task), Task.Parser, new[]{ "Id", "TaskName", "Parameters" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Method), Method.Parser, new[]{ "Name", "Parameters", "AchievedTask", "Subtasks", "Constraints", "Conditions" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(TaskNetwork), TaskNetwork.Parser, new[]{ "Variables", "Subtasks", "Constraints" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Hierarchy), Hierarchy.Parser, new[]{ "AbstractTasks", "Methods", "InitialTaskNetwork" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Activity), Activity.Parser, new[]{ "Name", "Parameters", "Duration", "Conditions", "Effects", "Constraints" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(SchedulingExtension), SchedulingExtension.Parser, new[]{ "Activities", "Variables", "Constraints" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Schedule), Schedule.Parser, new[]{ "Activities", "VariableAssignments" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(Goal), Goal.Parser, new[]{ "Goal_", "Timing" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(TimedEffect), TimedEffect.Parser, new[]{ "Effect", "OccurrenceTime" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Assignment), Assignment.Parser, new[]{ "Fluent", "Value" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(GoalWithWeight), GoalWithWeight.Parser, new[]{ "Goal", "Weight" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(TimedGoalWithWeight), TimedGoalWithWeight.Parser, new[]{ "Goal", "Timing", "Weight" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(Metric), Metric.Parser, new[]{ "Kind", "Expression", "ActionCosts", "DefaultActionCost", "Goals", "TimedGoals" }, null, new[]{ typeof(Metric.Types.MetricKind) }, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(Problem), Problem.Parser, new[]{ "DomainName", "ProblemName", "Types_", "Fluents", "Objects", "Actions", "InitialState", "TimedEffects", "Goals", "Features", "Metrics", "Hierarchy", "SchedulingExtension", "TrajectoryConstraints", "DiscreteTime", "SelfOverlapping", "Epsilon" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(ActionInstance), ActionInstance.Parser, new[]{ "Id", "ActionName", "Parameters", "StartTime", "EndTime" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(MethodInstance), MethodInstance.Parser, new[]{ "Id", "MethodName", "Parameters", "Subtasks" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(PlanHierarchy), PlanHierarchy.Parser, new[]{ "RootTasks", "Methods" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(Plan), Plan.Parser, new[]{ "Actions", "Hierarchy", "Schedule" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(PlanRequest), PlanRequest.Parser, new[]{ "Problem", "ResolutionMode", "Timeout", "EngineOptions" }, null, new[]{ typeof(PlanRequest.Types.Mode) }, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(ValidationRequest), ValidationRequest.Parser, new[]{ "Problem", "Plan" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(LogMessage), LogMessage.Parser, new[]{ "Level", "Message" }, null, new[]{ typeof(LogMessage.Types.LogLevel) }, null),
          new pbr::GeneratedClrTypeInfo(typeof(PlanGenerationResult), PlanGenerationResult.Parser, new[]{ "Status", "Plan", "Metrics", "LogMessages", "Engine" }, null, new[]{ typeof(PlanGenerationResult.Types.Status) }, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(Engine), Engine.Parser, new[]{ "Name" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(ValidationResult), ValidationResult.Parser, new[]{ "Status", "LogMessages", "Engine" }, null, new[]{ typeof(ValidationResult.Types.ValidationResultStatus) }, null),
          new pbr::GeneratedClrTypeInfo(typeof(CompilerResult), CompilerResult.Parser, new[]{ "Problem", "MapBackPlan", "LogMessages", "Engine" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, })
                }));
        }
        #endregion

    }
    #region Enums
    /// <summary>
    /// The kind of an expression, which gives information related to its structure.
    /// </summary>
    public enum ExpressionKind
    {
        /// <summary>
        /// Default value, should not be used. Drop it if we are sure to never need it.
        /// </summary>
        [pbr::OriginalName("UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Constant atom. For instance `3` or `kitchen` (where `kitchen` is an object defined in the problem)
        /// </summary>
        [pbr::OriginalName("CONSTANT")] Constant = 1,
        /// <summary>
        /// Atom symbol representing a parameter from an outer scope. For instance `from` that would appear inside a `(move from to - location)` action.
        /// </summary>
        [pbr::OriginalName("PARAMETER")] Parameter = 2,
        /// <summary>
        /// Atom symbol representing a variable from an outer scope.
        /// This is typically used to represent the variables that are existentially or universally qualified in expressions.
        /// </summary>
        [pbr::OriginalName("VARIABLE")] Variable = 7,
        /// <summary>
        /// Atom symbol representing a fluent of the problem. For instance `at-robot`.
        /// </summary>
        [pbr::OriginalName("FLUENT_SYMBOL")] FluentSymbol = 3,
        /// <summary>
        /// Atom representing a function. For instance `+`, `=`, `and`, ...
        /// </summary>
        [pbr::OriginalName("FUNCTION_SYMBOL")] FunctionSymbol = 4,
        /// <summary>
        /// List. Application of some parameters to a fluent symbol. For instance `(at-robot l1)` or `(battery-charged)`
        /// The first element of the list must be a FLUENT_SYMBOL
        /// </summary>
        [pbr::OriginalName("STATE_VARIABLE")] StateVariable = 5,
        /// <summary>
        /// List. The expression is the application of some parameters to a function. For instance `(+ 1 3)`.
        /// The first element of the list must be a FUNCTION_SYMBOL
        /// </summary>
        [pbr::OriginalName("FUNCTION_APPLICATION")] FunctionApplication = 6,
        /// <summary>
        /// Atom symbol. Unique identifier of a task or action in the current scope.
        /// </summary>
        [pbr::OriginalName("CONTAINER_ID")] ContainerId = 8,
    }

    /// <summary>
    /// Features of the problem.
    /// Features are essential in that not supporting a feature `X` should allow disregarding any field tagged with `features: [X]`.
    /// </summary>
    public enum Feature
    {
        /// <summary>
        /// PROBLEM_CLASS
        /// </summary>
        [pbr::OriginalName("ACTION_BASED")] ActionBased = 0,
        [pbr::OriginalName("HIERARCHICAL")] Hierarchical = 26,
        [pbr::OriginalName("SCHEDULING")] Scheduling = 56,
        /// <summary>
        /// PROBLEM_TYPE
        /// </summary>
        [pbr::OriginalName("SIMPLE_NUMERIC_PLANNING")] SimpleNumericPlanning = 30,
        [pbr::OriginalName("GENERAL_NUMERIC_PLANNING")] GeneralNumericPlanning = 31,
        /// <summary>
        /// TIME
        /// </summary>
        [pbr::OriginalName("CONTINUOUS_TIME")] ContinuousTime = 1,
        [pbr::OriginalName("DISCRETE_TIME")] DiscreteTime = 2,
        [pbr::OriginalName("INTERMEDIATE_CONDITIONS_AND_EFFECTS")] IntermediateConditionsAndEffects = 3,
        [pbr::OriginalName("EXTERNAL_CONDITIONS_AND_EFFECTS")] ExternalConditionsAndEffects = 39,
        [pbr::OriginalName("TIMED_EFFECTS")] TimedEffects = 4,
        [pbr::OriginalName("TIMED_GOALS")] TimedGoals = 5,
        [pbr::OriginalName("DURATION_INEQUALITIES")] DurationInequalities = 6,
        [pbr::OriginalName("SELF_OVERLAPPING")] SelfOverlapping = 47,
        /// <summary>
        /// EXPRESSION_DURATION
        /// </summary>
        [pbr::OriginalName("STATIC_FLUENTS_IN_DURATIONS")] StaticFluentsInDurations = 27,
        [pbr::OriginalName("FLUENTS_IN_DURATIONS")] FluentsInDurations = 28,
        /// <summary>
        /// NUMBERS
        /// </summary>
        [pbr::OriginalName("CONTINUOUS_NUMBERS")] ContinuousNumbers = 7,
        [pbr::OriginalName("DISCRETE_NUMBERS")] DiscreteNumbers = 8,
        [pbr::OriginalName("BOUNDED_TYPES")] BoundedTypes = 38,
        /// <summary>
        /// CONDITIONS_KIND
        /// </summary>
        [pbr::OriginalName("NEGATIVE_CONDITIONS")] NegativeConditions = 9,
        [pbr::OriginalName("DISJUNCTIVE_CONDITIONS")] DisjunctiveConditions = 10,
        [pbr::OriginalName("EQUALITIES")] Equalities = 11,
        [pbr::OriginalName("EXISTENTIAL_CONDITIONS")] ExistentialConditions = 12,
        [pbr::OriginalName("UNIVERSAL_CONDITIONS")] UniversalConditions = 13,
        /// <summary>
        /// EFFECTS_KIND
        /// </summary>
        [pbr::OriginalName("CONDITIONAL_EFFECTS")] ConditionalEffects = 14,
        [pbr::OriginalName("INCREASE_EFFECTS")] IncreaseEffects = 15,
        [pbr::OriginalName("DECREASE_EFFECTS")] DecreaseEffects = 16,
        [pbr::OriginalName("STATIC_FLUENTS_IN_BOOLEAN_ASSIGNMENTS")] StaticFluentsInBooleanAssignments = 41,
        [pbr::OriginalName("STATIC_FLUENTS_IN_NUMERIC_ASSIGNMENTS")] StaticFluentsInNumericAssignments = 42,
        [pbr::OriginalName("STATIC_FLUENTS_IN_OBJECT_ASSIGNMENTS")] StaticFluentsInObjectAssignments = 57,
        [pbr::OriginalName("FLUENTS_IN_BOOLEAN_ASSIGNMENTS")] FluentsInBooleanAssignments = 43,
        [pbr::OriginalName("FLUENTS_IN_NUMERIC_ASSIGNMENTS")] FluentsInNumericAssignments = 44,
        [pbr::OriginalName("FLUENTS_IN_OBJECT_ASSIGNMENTS")] FluentsInObjectAssignments = 58,
        [pbr::OriginalName("FORALL_EFFECTS")] ForallEffects = 59,
        /// <summary>
        /// TYPING
        /// </summary>
        [pbr::OriginalName("FLAT_TYPING")] FlatTyping = 17,
        [pbr::OriginalName("HIERARCHICAL_TYPING")] HierarchicalTyping = 18,
        /// <summary>
        /// FLUENTS_TYPE
        /// </summary>
        [pbr::OriginalName("NUMERIC_FLUENTS")] NumericFluents = 19,
        [pbr::OriginalName("OBJECT_FLUENTS")] ObjectFluents = 20,
        /// <summary>
        /// PARAMETERS
        /// </summary>
        [pbr::OriginalName("BOOL_FLUENT_PARAMETERS")] BoolFluentParameters = 50,
        [pbr::OriginalName("BOUNDED_INT_FLUENT_PARAMETERS")] BoundedIntFluentParameters = 51,
        [pbr::OriginalName("BOOL_ACTION_PARAMETERS")] BoolActionParameters = 52,
        [pbr::OriginalName("BOUNDED_INT_ACTION_PARAMETERS")] BoundedIntActionParameters = 53,
        [pbr::OriginalName("UNBOUNDED_INT_ACTION_PARAMETERS")] UnboundedIntActionParameters = 54,
        [pbr::OriginalName("REAL_ACTION_PARAMETERS")] RealActionParameters = 55,
        /// <summary>
        /// QUALITY_METRICS
        /// </summary>
        [pbr::OriginalName("ACTIONS_COST")] ActionsCost = 21,
        [pbr::OriginalName("FINAL_VALUE")] FinalValue = 22,
        [pbr::OriginalName("MAKESPAN")] Makespan = 23,
        [pbr::OriginalName("PLAN_LENGTH")] PlanLength = 24,
        [pbr::OriginalName("OVERSUBSCRIPTION")] Oversubscription = 29,
        [pbr::OriginalName("TEMPORAL_OVERSUBSCRIPTION")] TemporalOversubscription = 40,
        /// <summary>
        /// ACTION_COST_KIND
        /// </summary>
        [pbr::OriginalName("STATIC_FLUENTS_IN_ACTIONS_COST")] StaticFluentsInActionsCost = 45,
        [pbr::OriginalName("FLUENTS_IN_ACTIONS_COST")] FluentsInActionsCost = 46,
        /// <summary>
        /// SIMULATED_ENTITIES
        /// </summary>
        [pbr::OriginalName("SIMULATED_EFFECTS")] SimulatedEffects = 25,
        /// <summary>
        /// CONSTRAINTS_KIND
        /// </summary>
        [pbr::OriginalName("TRAJECTORY_CONSTRAINTS")] TrajectoryConstraints = 48,
        [pbr::OriginalName("STATE_INVARIANTS")] StateInvariants = 49,
        /// <summary>
        /// HIERARCHICAL
        /// </summary>
        [pbr::OriginalName("METHOD_PRECONDITIONS")] MethodPreconditions = 32,
        [pbr::OriginalName("TASK_NETWORK_CONSTRAINTS")] TaskNetworkConstraints = 33,
        [pbr::OriginalName("INITIAL_TASK_NETWORK_VARIABLES")] InitialTaskNetworkVariables = 34,
        [pbr::OriginalName("TASK_ORDER_TOTAL")] TaskOrderTotal = 35,
        [pbr::OriginalName("TASK_ORDER_PARTIAL")] TaskOrderPartial = 36,
        [pbr::OriginalName("TASK_ORDER_TEMPORAL")] TaskOrderTemporal = 37,
    }

    #endregion

    #region Messages
    /// <summary>
    /// As in s-expression, an Expression is either an atom or list representing the application of some parameters to a function/fluent.
    /// </summary>
    public sealed partial class Expression : pb::IMessage<Expression>
    {
        private static readonly pb::MessageParser<Expression> _parser = new pb::MessageParser<Expression>(() => new Expression());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Expression> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[0]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression(Expression other) : this()
        {
            atom_ = other.atom_ != null ? other.atom_.Clone() : null;
            list_ = other.list_.Clone();
            type_ = other.type_;
            kind_ = other.kind_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Clone()
        {
            return new Expression(this);
        }

        /// <summary>Field number for the "atom" field.</summary>
        public const int AtomFieldNumber = 1;
        private Atom atom_;
        /// <summary>
        /// If non-empty, the expression is a single atom.
        /// For instance `3`, `+`, `kitchen`, `at-robot`, ...
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Atom Atom
        {
            get { return atom_; }
            set
            {
                atom_ = value;
            }
        }

        /// <summary>Field number for the "list" field.</summary>
        public const int ListFieldNumber = 2;
        private static readonly pb::FieldCodec<Expression> _repeated_list_codec
            = pb::FieldCodec.ForMessage(18, Expression.Parser);
        private readonly pbc::RepeatedField<Expression> list_ = new pbc::RepeatedField<Expression>();
        /// <summary>
        /// If the `atom` field is empty, then the expression is a list of sub-expressions,
        /// typically representing the application of some arguments to a function or fluent.
        /// For instance `(+ 1 3)`, (at-robot l1)`, `(>= (battery_level) 20)`
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Expression> List
        {
            get { return list_; }
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 3;
        private string type_ = "";
        /// <summary>
        /// Type of the expression. For instance "int", "location", ...
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Type
        {
            get { return type_; }
            set
            {
                type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "kind" field.</summary>
        public const int KindFieldNumber = 4;
        private ExpressionKind kind_ = 0;
        /// <summary>
        /// Kind of the expression, specifying the content of the expression.
        /// This is intended to facilitate parsing of the expression.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExpressionKind Kind
        {
            get { return kind_; }
            set
            {
                kind_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Expression);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Expression other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Atom, other.Atom)) return false;
            if (!list_.Equals(other.list_)) return false;
            if (Type != other.Type) return false;
            if (Kind != other.Kind) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (atom_ != null) hash ^= Atom.GetHashCode();
            hash ^= list_.GetHashCode();
            if (Type.Length != 0) hash ^= Type.GetHashCode();
            if (Kind != 0) hash ^= Kind.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (atom_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Atom);
            }
            list_.WriteTo(output, _repeated_list_codec);
            if (Type.Length != 0)
            {
                output.WriteRawTag(26);
                output.WriteString(Type);
            }
            if (Kind != 0)
            {
                output.WriteRawTag(32);
                output.WriteEnum((int)Kind);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (atom_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Atom);
            }
            size += list_.CalculateSize(_repeated_list_codec);
            if (Type.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
            }
            if (Kind != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Kind);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Expression other)
        {
            if (other == null)
            {
                return;
            }
            if (other.atom_ != null)
            {
                if (atom_ == null)
                {
                    atom_ = new Atom();
                }
                Atom.MergeFrom(other.Atom);
            }
            list_.Add(other.list_);
            if (other.Type.Length != 0)
            {
                Type = other.Type;
            }
            if (other.Kind != 0)
            {
                Kind = other.Kind;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (atom_ == null)
                            {
                                atom_ = new Atom();
                            }
                            input.ReadMessage(atom_);
                            break;
                        }
                    case 18:
                        {
                            list_.AddEntriesFrom(input, _repeated_list_codec);
                            break;
                        }
                    case 26:
                        {
                            Type = input.ReadString();
                            break;
                        }
                    case 32:
                        {
                            kind_ = (ExpressionKind)input.ReadEnum();
                            break;
                        }
                }
            }
        }

    }

    public sealed partial class Atom : pb::IMessage<Atom>
    {
        private static readonly pb::MessageParser<Atom> _parser = new pb::MessageParser<Atom>(() => new Atom());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Atom> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[1]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Atom()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Atom(Atom other) : this()
        {
            switch (other.ContentCase)
            {
                case ContentOneofCase.Symbol:
                    Symbol = other.Symbol;
                    break;
                case ContentOneofCase.Int:
                    Int = other.Int;
                    break;
                case ContentOneofCase.Real:
                    Real = other.Real.Clone();
                    break;
                case ContentOneofCase.Boolean:
                    Boolean = other.Boolean;
                    break;
            }

            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Atom Clone()
        {
            return new Atom(this);
        }

        /// <summary>Field number for the "symbol" field.</summary>
        public const int SymbolFieldNumber = 1;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Symbol
        {
            get { return contentCase_ == ContentOneofCase.Symbol ? (string)content_ : ""; }
            set
            {
                content_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                contentCase_ = ContentOneofCase.Symbol;
            }
        }

        /// <summary>Field number for the "int" field.</summary>
        public const int IntFieldNumber = 2;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long Int
        {
            get { return contentCase_ == ContentOneofCase.Int ? (long)content_ : 0L; }
            set
            {
                content_ = value;
                contentCase_ = ContentOneofCase.Int;
            }
        }

        /// <summary>Field number for the "real" field.</summary>
        public const int RealFieldNumber = 3;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Real Real
        {
            get { return contentCase_ == ContentOneofCase.Real ? (Real)content_ : null; }
            set
            {
                content_ = value;
                contentCase_ = value == null ? ContentOneofCase.None : ContentOneofCase.Real;
            }
        }

        /// <summary>Field number for the "boolean" field.</summary>
        public const int BooleanFieldNumber = 4;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Boolean
        {
            get { return contentCase_ == ContentOneofCase.Boolean ? (bool)content_ : false; }
            set
            {
                content_ = value;
                contentCase_ = ContentOneofCase.Boolean;
            }
        }

        private object content_;
        /// <summary>Enum of possible cases for the "content" oneof.</summary>
        public enum ContentOneofCase
        {
            None = 0,
            Symbol = 1,
            Int = 2,
            Real = 3,
            Boolean = 4,
        }
        private ContentOneofCase contentCase_ = ContentOneofCase.None;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ContentOneofCase ContentCase
        {
            get { return contentCase_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearContent()
        {
            contentCase_ = ContentOneofCase.None;
            content_ = null;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Atom);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Atom other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Symbol != other.Symbol) return false;
            if (Int != other.Int) return false;
            if (!object.Equals(Real, other.Real)) return false;
            if (Boolean != other.Boolean) return false;
            if (ContentCase != other.ContentCase) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (contentCase_ == ContentOneofCase.Symbol) hash ^= Symbol.GetHashCode();
            if (contentCase_ == ContentOneofCase.Int) hash ^= Int.GetHashCode();
            if (contentCase_ == ContentOneofCase.Real) hash ^= Real.GetHashCode();
            if (contentCase_ == ContentOneofCase.Boolean) hash ^= Boolean.GetHashCode();
            hash ^= (int)contentCase_;
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (contentCase_ == ContentOneofCase.Symbol)
            {
                output.WriteRawTag(10);
                output.WriteString(Symbol);
            }
            if (contentCase_ == ContentOneofCase.Int)
            {
                output.WriteRawTag(16);
                output.WriteInt64(Int);
            }
            if (contentCase_ == ContentOneofCase.Real)
            {
                output.WriteRawTag(26);
                output.WriteMessage(Real);
            }
            if (contentCase_ == ContentOneofCase.Boolean)
            {
                output.WriteRawTag(32);
                output.WriteBool(Boolean);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (contentCase_ == ContentOneofCase.Symbol)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
            }
            if (contentCase_ == ContentOneofCase.Int)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(Int);
            }
            if (contentCase_ == ContentOneofCase.Real)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Real);
            }
            if (contentCase_ == ContentOneofCase.Boolean)
            {
                size += 1 + 1;
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Atom other)
        {
            if (other == null)
            {
                return;
            }
            switch (other.ContentCase)
            {
                case ContentOneofCase.Symbol:
                    Symbol = other.Symbol;
                    break;
                case ContentOneofCase.Int:
                    Int = other.Int;
                    break;
                case ContentOneofCase.Real:
                    if (Real == null)
                    {
                        Real = new Real();
                    }
                    Real.MergeFrom(other.Real);
                    break;
                case ContentOneofCase.Boolean:
                    Boolean = other.Boolean;
                    break;
            }

            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Symbol = input.ReadString();
                            break;
                        }
                    case 16:
                        {
                            Int = input.ReadInt64();
                            break;
                        }
                    case 26:
                        {
                            Real subBuilder = new Real();
                            if (contentCase_ == ContentOneofCase.Real)
                            {
                                subBuilder.MergeFrom(Real);
                            }
                            input.ReadMessage(subBuilder);
                            Real = subBuilder;
                            break;
                        }
                    case 32:
                        {
                            Boolean = input.ReadBool();
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Representation of a constant real number, as the fraction `(numerator / denominator)`.
    /// A real should be in its canonical form (with smallest possible denominator).
    /// Notably, if this number is an integer, then it is guaranteed that `denominator == 1`.
    /// </summary>
    public sealed partial class Real : pb::IMessage<Real>
    {
        private static readonly pb::MessageParser<Real> _parser = new pb::MessageParser<Real>(() => new Real());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Real> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[2]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Real()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Real(Real other) : this()
        {
            numerator_ = other.numerator_;
            denominator_ = other.denominator_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Real Clone()
        {
            return new Real(this);
        }

        /// <summary>Field number for the "numerator" field.</summary>
        public const int NumeratorFieldNumber = 1;
        private long numerator_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long Numerator
        {
            get { return numerator_; }
            set
            {
                numerator_ = value;
            }
        }

        /// <summary>Field number for the "denominator" field.</summary>
        public const int DenominatorFieldNumber = 2;
        private long denominator_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long Denominator
        {
            get { return denominator_; }
            set
            {
                denominator_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Real);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Real other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Numerator != other.Numerator) return false;
            if (Denominator != other.Denominator) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Numerator != 0L) hash ^= Numerator.GetHashCode();
            if (Denominator != 0L) hash ^= Denominator.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Numerator != 0L)
            {
                output.WriteRawTag(8);
                output.WriteInt64(Numerator);
            }
            if (Denominator != 0L)
            {
                output.WriteRawTag(16);
                output.WriteInt64(Denominator);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Numerator != 0L)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(Numerator);
            }
            if (Denominator != 0L)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(Denominator);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Real other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Numerator != 0L)
            {
                Numerator = other.Numerator;
            }
            if (other.Denominator != 0L)
            {
                Denominator = other.Denominator;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 8:
                        {
                            Numerator = input.ReadInt64();
                            break;
                        }
                    case 16:
                        {
                            Denominator = input.ReadInt64();
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Declares the existence of a symbolic type.
    /// </summary>
    public sealed partial class TypeDeclaration : pb::IMessage<TypeDeclaration>
    {
        private static readonly pb::MessageParser<TypeDeclaration> _parser = new pb::MessageParser<TypeDeclaration>(() => new TypeDeclaration());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TypeDeclaration> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[3]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TypeDeclaration()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TypeDeclaration(TypeDeclaration other) : this()
        {
            typeName_ = other.typeName_;
            parentType_ = other.parentType_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TypeDeclaration Clone()
        {
            return new TypeDeclaration(this);
        }

        /// <summary>Field number for the "type_name" field.</summary>
        public const int TypeNameFieldNumber = 1;
        private string typeName_ = "";
        /// <summary>
        /// Name of the type that is declared.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string TypeName
        {
            get { return typeName_; }
            set
            {
                typeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "parent_type" field.</summary>
        public const int ParentTypeFieldNumber = 2;
        private string parentType_ = "";
        /// <summary>
        /// Optional. If the string is non-empty, this is the parent type of `type_name`.
        /// If set, the parent type must have been previously declared (i.e. should appear earlier in the problem's type declarations.
        /// feature: HIERARCHICAL_TYPING
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ParentType
        {
            get { return parentType_; }
            set
            {
                parentType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TypeDeclaration);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TypeDeclaration other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (TypeName != other.TypeName) return false;
            if (ParentType != other.ParentType) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (TypeName.Length != 0) hash ^= TypeName.GetHashCode();
            if (ParentType.Length != 0) hash ^= ParentType.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (TypeName.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(TypeName);
            }
            if (ParentType.Length != 0)
            {
                output.WriteRawTag(18);
                output.WriteString(ParentType);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (TypeName.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(TypeName);
            }
            if (ParentType.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ParentType);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TypeDeclaration other)
        {
            if (other == null)
            {
                return;
            }
            if (other.TypeName.Length != 0)
            {
                TypeName = other.TypeName;
            }
            if (other.ParentType.Length != 0)
            {
                ParentType = other.ParentType;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            TypeName = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            ParentType = input.ReadString();
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Parameter of a fluent or of an action
    /// </summary>
    public sealed partial class Parameter : pb::IMessage<Parameter>
    {
        private static readonly pb::MessageParser<Parameter> _parser = new pb::MessageParser<Parameter>(() => new Parameter());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Parameter> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[4]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Parameter()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Parameter(Parameter other) : this()
        {
            name_ = other.name_;
            type_ = other.type_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Parameter Clone()
        {
            return new Parameter(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Name of the parameter.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 2;
        private string type_ = "";
        /// <summary>
        /// Type of the parameter.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Type
        {
            get { return type_; }
            set
            {
                type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Parameter);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Parameter other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (Type != other.Type) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Name.Length != 0) hash ^= Name.GetHashCode();
            if (Type.Length != 0) hash ^= Type.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Name.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            if (Type.Length != 0)
            {
                output.WriteRawTag(18);
                output.WriteString(Type);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Name.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (Type.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Parameter other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Name.Length != 0)
            {
                Name = other.Name;
            }
            if (other.Type.Length != 0)
            {
                Type = other.Type;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            Type = input.ReadString();
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// A state-dependent variable.
    /// </summary>
    public sealed partial class Fluent : pb::IMessage<Fluent>
    {
        private static readonly pb::MessageParser<Fluent> _parser = new pb::MessageParser<Fluent>(() => new Fluent());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Fluent> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[5]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Fluent()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Fluent(Fluent other) : this()
        {
            name_ = other.name_;
            valueType_ = other.valueType_;
            parameters_ = other.parameters_.Clone();
            defaultValue_ = other.defaultValue_ != null ? other.defaultValue_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Fluent Clone()
        {
            return new Fluent(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "value_type" field.</summary>
        public const int ValueTypeFieldNumber = 2;
        private string valueType_ = "";
        /// <summary>
        /// Return type of the fluent.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ValueType
        {
            get { return valueType_; }
            set
            {
                valueType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "parameters" field.</summary>
        public const int ParametersFieldNumber = 3;
        private static readonly pb::FieldCodec<Parameter> _repeated_parameters_codec
            = pb::FieldCodec.ForMessage(26, Parameter.Parser);
        private readonly pbc::RepeatedField<Parameter> parameters_ = new pbc::RepeatedField<Parameter>();
        /// <summary>
        /// Typed and named parameters of the fluent.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Parameter> Parameters
        {
            get { return parameters_; }
        }

        /// <summary>Field number for the "default_value" field.</summary>
        public const int DefaultValueFieldNumber = 4;
        private Expression defaultValue_;
        /// <summary>
        /// If non-empty, then any state variable using this fluent that is not explicitly given a value in the initial state
        /// will be assumed to have this default value.
        /// This allows mimicking the closed world assumption by setting a "false" default value to predicates.
        /// Note that in the initial state of the problem message, it is assumed that all default values are set.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression DefaultValue
        {
            get { return defaultValue_; }
            set
            {
                defaultValue_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Fluent);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Fluent other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (ValueType != other.ValueType) return false;
            if (!parameters_.Equals(other.parameters_)) return false;
            if (!object.Equals(DefaultValue, other.DefaultValue)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Name.Length != 0) hash ^= Name.GetHashCode();
            if (ValueType.Length != 0) hash ^= ValueType.GetHashCode();
            hash ^= parameters_.GetHashCode();
            if (defaultValue_ != null) hash ^= DefaultValue.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Name.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            if (ValueType.Length != 0)
            {
                output.WriteRawTag(18);
                output.WriteString(ValueType);
            }
            parameters_.WriteTo(output, _repeated_parameters_codec);
            if (defaultValue_ != null)
            {
                output.WriteRawTag(34);
                output.WriteMessage(DefaultValue);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Name.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (ValueType.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ValueType);
            }
            size += parameters_.CalculateSize(_repeated_parameters_codec);
            if (defaultValue_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultValue);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Fluent other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Name.Length != 0)
            {
                Name = other.Name;
            }
            if (other.ValueType.Length != 0)
            {
                ValueType = other.ValueType;
            }
            parameters_.Add(other.parameters_);
            if (other.defaultValue_ != null)
            {
                if (defaultValue_ == null)
                {
                    defaultValue_ = new Expression();
                }
                DefaultValue.MergeFrom(other.DefaultValue);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            ValueType = input.ReadString();
                            break;
                        }
                    case 26:
                        {
                            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
                            break;
                        }
                    case 34:
                        {
                            if (defaultValue_ == null)
                            {
                                defaultValue_ = new Expression();
                            }
                            input.ReadMessage(defaultValue_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Declares an object with the given name and type.
    /// </summary>
    public sealed partial class ObjectDeclaration : pb::IMessage<ObjectDeclaration>
    {
        private static readonly pb::MessageParser<ObjectDeclaration> _parser = new pb::MessageParser<ObjectDeclaration>(() => new ObjectDeclaration());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ObjectDeclaration> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[6]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ObjectDeclaration()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ObjectDeclaration(ObjectDeclaration other) : this()
        {
            name_ = other.name_;
            type_ = other.type_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ObjectDeclaration Clone()
        {
            return new ObjectDeclaration(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Name of the object.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 2;
        private string type_ = "";
        /// <summary>
        /// Type of the object.
        /// The type must have been previously declared in the problem definition.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Type
        {
            get { return type_; }
            set
            {
                type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as ObjectDeclaration);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ObjectDeclaration other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (Type != other.Type) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Name.Length != 0) hash ^= Name.GetHashCode();
            if (Type.Length != 0) hash ^= Type.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Name.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            if (Type.Length != 0)
            {
                output.WriteRawTag(18);
                output.WriteString(Type);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Name.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (Type.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ObjectDeclaration other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Name.Length != 0)
            {
                Name = other.Name;
            }
            if (other.Type.Length != 0)
            {
                Type = other.Type;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            Type = input.ReadString();
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// An effect expression is of the form `FLUENT OP VALUE`.
    /// We explicitly restrict the different types of effects by setting the allowed operators.
    /// </summary>
    public sealed partial class EffectExpression : pb::IMessage<EffectExpression>
    {
        private static readonly pb::MessageParser<EffectExpression> _parser = new pb::MessageParser<EffectExpression>(() => new EffectExpression());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<EffectExpression> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[7]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EffectExpression()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EffectExpression(EffectExpression other) : this()
        {
            kind_ = other.kind_;
            fluent_ = other.fluent_ != null ? other.fluent_.Clone() : null;
            value_ = other.value_ != null ? other.value_.Clone() : null;
            condition_ = other.condition_ != null ? other.condition_.Clone() : null;
            forall_ = other.forall_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EffectExpression Clone()
        {
            return new EffectExpression(this);
        }

        /// <summary>Field number for the "kind" field.</summary>
        public const int KindFieldNumber = 1;
        private EffectExpression.Types.EffectKind kind_ = 0;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EffectExpression.Types.EffectKind Kind
        {
            get { return kind_; }
            set
            {
                kind_ = value;
            }
        }

        /// <summary>Field number for the "fluent" field.</summary>
        public const int FluentFieldNumber = 2;
        private Expression fluent_;
        /// <summary>
        /// Expression that must be of the STATE_VARIABLE kind.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Fluent
        {
            get { return fluent_; }
            set
            {
                fluent_ = value;
            }
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 3;
        private Expression value_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Value
        {
            get { return value_; }
            set
            {
                value_ = value;
            }
        }

        /// <summary>Field number for the "condition" field.</summary>
        public const int ConditionFieldNumber = 4;
        private Expression condition_;
        /// <summary>
        /// Optional. If the effect is conditional, then the following field must be set.
        /// In this case, the `effect` will only be applied if the `condition`` holds.
        /// If the effect is unconditional, the effect is set to the constant 'true' value.
        /// features: CONDITIONAL_EFFECT
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Condition
        {
            get { return condition_; }
            set
            {
                condition_ = value;
            }
        }

        /// <summary>Field number for the "forall" field.</summary>
        public const int ForallFieldNumber = 5;
        private static readonly pb::FieldCodec<Expression> _repeated_forall_codec
            = pb::FieldCodec.ForMessage(42, Expression.Parser);
        private readonly pbc::RepeatedField<Expression> forall_ = new pbc::RepeatedField<Expression>();
        /// <summary>
        /// The variables that quantify this effect
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Expression> Forall
        {
            get { return forall_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as EffectExpression);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(EffectExpression other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Kind != other.Kind) return false;
            if (!object.Equals(Fluent, other.Fluent)) return false;
            if (!object.Equals(Value, other.Value)) return false;
            if (!object.Equals(Condition, other.Condition)) return false;
            if (!forall_.Equals(other.forall_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Kind != 0) hash ^= Kind.GetHashCode();
            if (fluent_ != null) hash ^= Fluent.GetHashCode();
            if (value_ != null) hash ^= Value.GetHashCode();
            if (condition_ != null) hash ^= Condition.GetHashCode();
            hash ^= forall_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Kind != 0)
            {
                output.WriteRawTag(8);
                output.WriteEnum((int)Kind);
            }
            if (fluent_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Fluent);
            }
            if (value_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(Value);
            }
            if (condition_ != null)
            {
                output.WriteRawTag(34);
                output.WriteMessage(Condition);
            }
            forall_.WriteTo(output, _repeated_forall_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Kind != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Kind);
            }
            if (fluent_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Fluent);
            }
            if (value_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Value);
            }
            if (condition_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Condition);
            }
            size += forall_.CalculateSize(_repeated_forall_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(EffectExpression other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Kind != 0)
            {
                Kind = other.Kind;
            }
            if (other.fluent_ != null)
            {
                if (fluent_ == null)
                {
                    fluent_ = new Expression();
                }
                Fluent.MergeFrom(other.Fluent);
            }
            if (other.value_ != null)
            {
                if (value_ == null)
                {
                    value_ = new Expression();
                }
                Value.MergeFrom(other.Value);
            }
            if (other.condition_ != null)
            {
                if (condition_ == null)
                {
                    condition_ = new Expression();
                }
                Condition.MergeFrom(other.Condition);
            }
            forall_.Add(other.forall_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 8:
                        {
                            kind_ = (EffectExpression.Types.EffectKind)input.ReadEnum();
                            break;
                        }
                    case 18:
                        {
                            if (fluent_ == null)
                            {
                                fluent_ = new Expression();
                            }
                            input.ReadMessage(fluent_);
                            break;
                        }
                    case 26:
                        {
                            if (value_ == null)
                            {
                                value_ = new Expression();
                            }
                            input.ReadMessage(value_);
                            break;
                        }
                    case 34:
                        {
                            if (condition_ == null)
                            {
                                condition_ = new Expression();
                            }
                            input.ReadMessage(condition_);
                            break;
                        }
                    case 42:
                        {
                            forall_.AddEntriesFrom(input, _repeated_forall_codec);
                            break;
                        }
                }
            }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the EffectExpression message type.</summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types
        {
            public enum EffectKind
            {
                /// <summary>
                /// The `fluent` is set to the corresponding `value`
                /// </summary>
                [pbr::OriginalName("ASSIGN")] Assign = 0,
                /// <summary>
                /// The `fluent` is increased by the amount `value`
                /// features: INCREASE_EFFECTS
                /// </summary>
                [pbr::OriginalName("INCREASE")] Increase = 1,
                /// <summary>
                /// The `fluent` is decreased by the amount `value`
                /// features: DECREASE_EFFECTS
                /// </summary>
                [pbr::OriginalName("DECREASE")] Decrease = 2,
            }

        }
        #endregion

    }

    /// <summary>
    /// Representation of an effect that allows qualifying the effect expression, e.g., to make it a conditional effect.
    /// </summary>
    public sealed partial class Effect : pb::IMessage<Effect>
    {
        private static readonly pb::MessageParser<Effect> _parser = new pb::MessageParser<Effect>(() => new Effect());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Effect> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[8]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Effect()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Effect(Effect other) : this()
        {
            effect_ = other.effect_ != null ? other.effect_.Clone() : null;
            occurrenceTime_ = other.occurrenceTime_ != null ? other.occurrenceTime_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Effect Clone()
        {
            return new Effect(this);
        }

        /// <summary>Field number for the "effect" field.</summary>
        public const int Effect_FieldNumber = 1;
        private EffectExpression effect_;
        /// <summary>
        /// Required. The actual effect that should take place.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EffectExpression Effect_
        {
            get { return effect_; }
            set
            {
                effect_ = value;
            }
        }

        /// <summary>Field number for the "occurrence_time" field.</summary>
        public const int OccurrenceTimeFieldNumber = 2;
        private Timing occurrenceTime_;
        /// <summary>
        /// Optional. If the effect is within a durative action, the following must be set and will specify when the effect takes place.
        /// features: DURATIVE_ACTIONS
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timing OccurrenceTime
        {
            get { return occurrenceTime_; }
            set
            {
                occurrenceTime_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Effect);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Effect other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Effect_, other.Effect_)) return false;
            if (!object.Equals(OccurrenceTime, other.OccurrenceTime)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (effect_ != null) hash ^= Effect_.GetHashCode();
            if (occurrenceTime_ != null) hash ^= OccurrenceTime.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (effect_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Effect_);
            }
            if (occurrenceTime_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(OccurrenceTime);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (effect_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Effect_);
            }
            if (occurrenceTime_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(OccurrenceTime);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Effect other)
        {
            if (other == null)
            {
                return;
            }
            if (other.effect_ != null)
            {
                if (effect_ == null)
                {
                    effect_ = new EffectExpression();
                }
                Effect_.MergeFrom(other.Effect_);
            }
            if (other.occurrenceTime_ != null)
            {
                if (occurrenceTime_ == null)
                {
                    occurrenceTime_ = new Timing();
                }
                OccurrenceTime.MergeFrom(other.OccurrenceTime);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (effect_ == null)
                            {
                                effect_ = new EffectExpression();
                            }
                            input.ReadMessage(effect_);
                            break;
                        }
                    case 18:
                        {
                            if (occurrenceTime_ == null)
                            {
                                occurrenceTime_ = new Timing();
                            }
                            input.ReadMessage(occurrenceTime_);
                            break;
                        }
                }
            }
        }

    }

    public sealed partial class Condition : pb::IMessage<Condition>
    {
        private static readonly pb::MessageParser<Condition> _parser = new pb::MessageParser<Condition>(() => new Condition());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Condition> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[9]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Condition()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Condition(Condition other) : this()
        {
            cond_ = other.cond_ != null ? other.cond_.Clone() : null;
            span_ = other.span_ != null ? other.span_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Condition Clone()
        {
            return new Condition(this);
        }

        /// <summary>Field number for the "cond" field.</summary>
        public const int CondFieldNumber = 1;
        private Expression cond_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Cond
        {
            get { return cond_; }
            set
            {
                cond_ = value;
            }
        }

        /// <summary>Field number for the "span" field.</summary>
        public const int SpanFieldNumber = 2;
        private TimeInterval span_;
        /// <summary>
        /// Optional. Must be set for durative actions where it specifies the temporal interval
        /// over which when the condition should hold.
        /// features: DURATIVE_ACTIONS
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeInterval Span
        {
            get { return span_; }
            set
            {
                span_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Condition);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Condition other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Cond, other.Cond)) return false;
            if (!object.Equals(Span, other.Span)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (cond_ != null) hash ^= Cond.GetHashCode();
            if (span_ != null) hash ^= Span.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (cond_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Cond);
            }
            if (span_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Span);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (cond_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cond);
            }
            if (span_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Span);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Condition other)
        {
            if (other == null)
            {
                return;
            }
            if (other.cond_ != null)
            {
                if (cond_ == null)
                {
                    cond_ = new Expression();
                }
                Cond.MergeFrom(other.Cond);
            }
            if (other.span_ != null)
            {
                if (span_ == null)
                {
                    span_ = new TimeInterval();
                }
                Span.MergeFrom(other.Span);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (cond_ == null)
                            {
                                cond_ = new Expression();
                            }
                            input.ReadMessage(cond_);
                            break;
                        }
                    case 18:
                        {
                            if (span_ == null)
                            {
                                span_ = new TimeInterval();
                            }
                            input.ReadMessage(span_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Unified action representation that represents any kind of actions.
    /// </summary>
    public sealed partial class Action : pb::IMessage<Action>
    {
        private static readonly pb::MessageParser<Action> _parser = new pb::MessageParser<Action>(() => new Action());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Action> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[10]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Action()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Action(Action other) : this()
        {
            name_ = other.name_;
            parameters_ = other.parameters_.Clone();
            duration_ = other.duration_ != null ? other.duration_.Clone() : null;
            conditions_ = other.conditions_.Clone();
            effects_ = other.effects_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Action Clone()
        {
            return new Action(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Action name. E.g. "move"
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "parameters" field.</summary>
        public const int ParametersFieldNumber = 2;
        private static readonly pb::FieldCodec<Parameter> _repeated_parameters_codec
            = pb::FieldCodec.ForMessage(18, Parameter.Parser);
        private readonly pbc::RepeatedField<Parameter> parameters_ = new pbc::RepeatedField<Parameter>();
        /// <summary>
        /// Typed and named parameters of the action.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Parameter> Parameters
        {
            get { return parameters_; }
        }

        /// <summary>Field number for the "duration" field.</summary>
        public const int DurationFieldNumber = 3;
        private Duration duration_;
        /// <summary>
        /// If set, the action is durative. Otherwise it is instantaneous.
        /// features: DURATIVE_ACTIONS
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Duration Duration
        {
            get { return duration_; }
            set
            {
                duration_ = value;
            }
        }

        /// <summary>Field number for the "conditions" field.</summary>
        public const int ConditionsFieldNumber = 4;
        private static readonly pb::FieldCodec<Condition> _repeated_conditions_codec
            = pb::FieldCodec.ForMessage(34, Condition.Parser);
        private readonly pbc::RepeatedField<Condition> conditions_ = new pbc::RepeatedField<Condition>();
        /// <summary>
        /// Conjunction of conditions that must hold for the action to be applicable.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Condition> Conditions
        {
            get { return conditions_; }
        }

        /// <summary>Field number for the "effects" field.</summary>
        public const int EffectsFieldNumber = 5;
        private static readonly pb::FieldCodec<Effect> _repeated_effects_codec
            = pb::FieldCodec.ForMessage(42, Effect.Parser);
        private readonly pbc::RepeatedField<Effect> effects_ = new pbc::RepeatedField<Effect>();
        /// <summary>
        /// Conjunction of effects as a result of applying this action.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Effect> Effects
        {
            get { return effects_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Action);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Action other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (!parameters_.Equals(other.parameters_)) return false;
            if (!object.Equals(Duration, other.Duration)) return false;
            if (!conditions_.Equals(other.conditions_)) return false;
            if (!effects_.Equals(other.effects_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Name.Length != 0) hash ^= Name.GetHashCode();
            hash ^= parameters_.GetHashCode();
            if (duration_ != null) hash ^= Duration.GetHashCode();
            hash ^= conditions_.GetHashCode();
            hash ^= effects_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Name.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            parameters_.WriteTo(output, _repeated_parameters_codec);
            if (duration_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(Duration);
            }
            conditions_.WriteTo(output, _repeated_conditions_codec);
            effects_.WriteTo(output, _repeated_effects_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Name.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            size += parameters_.CalculateSize(_repeated_parameters_codec);
            if (duration_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Duration);
            }
            size += conditions_.CalculateSize(_repeated_conditions_codec);
            size += effects_.CalculateSize(_repeated_effects_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Action other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Name.Length != 0)
            {
                Name = other.Name;
            }
            parameters_.Add(other.parameters_);
            if (other.duration_ != null)
            {
                if (duration_ == null)
                {
                    duration_ = new Duration();
                }
                Duration.MergeFrom(other.Duration);
            }
            conditions_.Add(other.conditions_);
            effects_.Add(other.effects_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
                            break;
                        }
                    case 26:
                        {
                            if (duration_ == null)
                            {
                                duration_ = new Duration();
                            }
                            input.ReadMessage(duration_);
                            break;
                        }
                    case 34:
                        {
                            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
                            break;
                        }
                    case 42:
                        {
                            effects_.AddEntriesFrom(input, _repeated_effects_codec);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Symbolic reference to an absolute time.
    /// It might represent:
    /// - the time of the initial/final state, or
    /// - the start/end of the containing action, or
    /// - the start/end of one of the subtask in the context of a method or of a task network.
    /// </summary>
    public sealed partial class Timepoint : pb::IMessage<Timepoint>
    {
        private static readonly pb::MessageParser<Timepoint> _parser = new pb::MessageParser<Timepoint>(() => new Timepoint());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Timepoint> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[11]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timepoint()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timepoint(Timepoint other) : this()
        {
            kind_ = other.kind_;
            containerId_ = other.containerId_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timepoint Clone()
        {
            return new Timepoint(this);
        }

        /// <summary>Field number for the "kind" field.</summary>
        public const int KindFieldNumber = 1;
        private Timepoint.Types.TimepointKind kind_ = 0;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timepoint.Types.TimepointKind Kind
        {
            get { return kind_; }
            set
            {
                kind_ = value;
            }
        }

        /// <summary>Field number for the "container_id" field.</summary>
        public const int ContainerIdFieldNumber = 2;
        private string containerId_ = "";
        /// <summary>
        /// If non-empty, identifies the container of which we are extracting the start/end timepoint.
        /// In the context of a task-network or of a method, this could be the `id` of one of the subtasks.
        /// feature: hierarchies
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ContainerId
        {
            get { return containerId_; }
            set
            {
                containerId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Timepoint);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Timepoint other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Kind != other.Kind) return false;
            if (ContainerId != other.ContainerId) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Kind != 0) hash ^= Kind.GetHashCode();
            if (ContainerId.Length != 0) hash ^= ContainerId.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Kind != 0)
            {
                output.WriteRawTag(8);
                output.WriteEnum((int)Kind);
            }
            if (ContainerId.Length != 0)
            {
                output.WriteRawTag(18);
                output.WriteString(ContainerId);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Kind != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Kind);
            }
            if (ContainerId.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ContainerId);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Timepoint other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Kind != 0)
            {
                Kind = other.Kind;
            }
            if (other.ContainerId.Length != 0)
            {
                ContainerId = other.ContainerId;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 8:
                        {
                            kind_ = (Timepoint.Types.TimepointKind)input.ReadEnum();
                            break;
                        }
                    case 18:
                        {
                            ContainerId = input.ReadString();
                            break;
                        }
                }
            }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Timepoint message type.</summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types
        {
            public enum TimepointKind
            {
                /// <summary>
                /// Global start of the planning problem. This is context independent and represents the time at which the initial state holds.
                /// </summary>
                [pbr::OriginalName("GLOBAL_START")] GlobalStart = 0,
                /// <summary>
                /// Global end of the planning problem. This is context independent and represents the time at which the final state holds.
                /// </summary>
                [pbr::OriginalName("GLOBAL_END")] GlobalEnd = 1,
                /// <summary>
                /// Start of the container (typically the action or method) in which this symbol occurs
                /// </summary>
                [pbr::OriginalName("START")] Start = 2,
                /// <summary>
                /// End of the container (typically the action or method) in which this symbol occurs
                /// </summary>
                [pbr::OriginalName("END")] End = 3,
            }

        }
        #endregion

    }

    /// <summary>
    /// Represents a time (`timepoint` + `delay`), that is a time defined relatively to a particular `timepoint`.
    /// Note that an absolute time can be defined by setting the `delay` relative to the `GLOBAL_START`` which is the reference time.
    /// </summary>
    public sealed partial class Timing : pb::IMessage<Timing>
    {
        private static readonly pb::MessageParser<Timing> _parser = new pb::MessageParser<Timing>(() => new Timing());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Timing> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[12]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timing()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timing(Timing other) : this()
        {
            timepoint_ = other.timepoint_ != null ? other.timepoint_.Clone() : null;
            delay_ = other.delay_ != null ? other.delay_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timing Clone()
        {
            return new Timing(this);
        }

        /// <summary>Field number for the "timepoint" field.</summary>
        public const int TimepointFieldNumber = 1;
        private Timepoint timepoint_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timepoint Timepoint
        {
            get { return timepoint_; }
            set
            {
                timepoint_ = value;
            }
        }

        /// <summary>Field number for the "delay" field.</summary>
        public const int DelayFieldNumber = 2;
        private Real delay_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Real Delay
        {
            get { return delay_; }
            set
            {
                delay_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Timing);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Timing other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Timepoint, other.Timepoint)) return false;
            if (!object.Equals(Delay, other.Delay)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (timepoint_ != null) hash ^= Timepoint.GetHashCode();
            if (delay_ != null) hash ^= Delay.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (timepoint_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Timepoint);
            }
            if (delay_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Delay);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (timepoint_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timepoint);
            }
            if (delay_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Delay);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Timing other)
        {
            if (other == null)
            {
                return;
            }
            if (other.timepoint_ != null)
            {
                if (timepoint_ == null)
                {
                    timepoint_ = new Timepoint();
                }
                Timepoint.MergeFrom(other.Timepoint);
            }
            if (other.delay_ != null)
            {
                if (delay_ == null)
                {
                    delay_ = new Real();
                }
                Delay.MergeFrom(other.Delay);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (timepoint_ == null)
                            {
                                timepoint_ = new Timepoint();
                            }
                            input.ReadMessage(timepoint_);
                            break;
                        }
                    case 18:
                        {
                            if (delay_ == null)
                            {
                                delay_ = new Real();
                            }
                            input.ReadMessage(delay_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// An interval `[lower, upper]` where `lower` and `upper` are arbitrary expressions.
    /// The `is_left_open` and `is_right_open` fields indicate whether the interval is
    /// opened on left and right side respectively.
    /// </summary>
    public sealed partial class Interval : pb::IMessage<Interval>
    {
        private static readonly pb::MessageParser<Interval> _parser = new pb::MessageParser<Interval>(() => new Interval());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Interval> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[13]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Interval()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Interval(Interval other) : this()
        {
            isLeftOpen_ = other.isLeftOpen_;
            lower_ = other.lower_ != null ? other.lower_.Clone() : null;
            isRightOpen_ = other.isRightOpen_;
            upper_ = other.upper_ != null ? other.upper_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Interval Clone()
        {
            return new Interval(this);
        }

        /// <summary>Field number for the "is_left_open" field.</summary>
        public const int IsLeftOpenFieldNumber = 1;
        private bool isLeftOpen_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsLeftOpen
        {
            get { return isLeftOpen_; }
            set
            {
                isLeftOpen_ = value;
            }
        }

        /// <summary>Field number for the "lower" field.</summary>
        public const int LowerFieldNumber = 2;
        private Expression lower_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Lower
        {
            get { return lower_; }
            set
            {
                lower_ = value;
            }
        }

        /// <summary>Field number for the "is_right_open" field.</summary>
        public const int IsRightOpenFieldNumber = 3;
        private bool isRightOpen_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsRightOpen
        {
            get { return isRightOpen_; }
            set
            {
                isRightOpen_ = value;
            }
        }

        /// <summary>Field number for the "upper" field.</summary>
        public const int UpperFieldNumber = 4;
        private Expression upper_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Upper
        {
            get { return upper_; }
            set
            {
                upper_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Interval);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Interval other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (IsLeftOpen != other.IsLeftOpen) return false;
            if (!object.Equals(Lower, other.Lower)) return false;
            if (IsRightOpen != other.IsRightOpen) return false;
            if (!object.Equals(Upper, other.Upper)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (IsLeftOpen != false) hash ^= IsLeftOpen.GetHashCode();
            if (lower_ != null) hash ^= Lower.GetHashCode();
            if (IsRightOpen != false) hash ^= IsRightOpen.GetHashCode();
            if (upper_ != null) hash ^= Upper.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (IsLeftOpen != false)
            {
                output.WriteRawTag(8);
                output.WriteBool(IsLeftOpen);
            }
            if (lower_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Lower);
            }
            if (IsRightOpen != false)
            {
                output.WriteRawTag(24);
                output.WriteBool(IsRightOpen);
            }
            if (upper_ != null)
            {
                output.WriteRawTag(34);
                output.WriteMessage(Upper);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (IsLeftOpen != false)
            {
                size += 1 + 1;
            }
            if (lower_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lower);
            }
            if (IsRightOpen != false)
            {
                size += 1 + 1;
            }
            if (upper_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Upper);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Interval other)
        {
            if (other == null)
            {
                return;
            }
            if (other.IsLeftOpen != false)
            {
                IsLeftOpen = other.IsLeftOpen;
            }
            if (other.lower_ != null)
            {
                if (lower_ == null)
                {
                    lower_ = new Expression();
                }
                Lower.MergeFrom(other.Lower);
            }
            if (other.IsRightOpen != false)
            {
                IsRightOpen = other.IsRightOpen;
            }
            if (other.upper_ != null)
            {
                if (upper_ == null)
                {
                    upper_ = new Expression();
                }
                Upper.MergeFrom(other.Upper);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 8:
                        {
                            IsLeftOpen = input.ReadBool();
                            break;
                        }
                    case 18:
                        {
                            if (lower_ == null)
                            {
                                lower_ = new Expression();
                            }
                            input.ReadMessage(lower_);
                            break;
                        }
                    case 24:
                        {
                            IsRightOpen = input.ReadBool();
                            break;
                        }
                    case 34:
                        {
                            if (upper_ == null)
                            {
                                upper_ = new Expression();
                            }
                            input.ReadMessage(upper_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// A contiguous slice of time represented as an interval `[lower, upper]` where `lower` and `upper` are time references.
    /// The `is_left_open` and `is_right_open` fields indicate whether the interval is
    /// opened on left and right side respectively.
    /// </summary>
    public sealed partial class TimeInterval : pb::IMessage<TimeInterval>
    {
        private static readonly pb::MessageParser<TimeInterval> _parser = new pb::MessageParser<TimeInterval>(() => new TimeInterval());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TimeInterval> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[14]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeInterval()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeInterval(TimeInterval other) : this()
        {
            isLeftOpen_ = other.isLeftOpen_;
            lower_ = other.lower_ != null ? other.lower_.Clone() : null;
            isRightOpen_ = other.isRightOpen_;
            upper_ = other.upper_ != null ? other.upper_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeInterval Clone()
        {
            return new TimeInterval(this);
        }

        /// <summary>Field number for the "is_left_open" field.</summary>
        public const int IsLeftOpenFieldNumber = 1;
        private bool isLeftOpen_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsLeftOpen
        {
            get { return isLeftOpen_; }
            set
            {
                isLeftOpen_ = value;
            }
        }

        /// <summary>Field number for the "lower" field.</summary>
        public const int LowerFieldNumber = 2;
        private Timing lower_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timing Lower
        {
            get { return lower_; }
            set
            {
                lower_ = value;
            }
        }

        /// <summary>Field number for the "is_right_open" field.</summary>
        public const int IsRightOpenFieldNumber = 3;
        private bool isRightOpen_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsRightOpen
        {
            get { return isRightOpen_; }
            set
            {
                isRightOpen_ = value;
            }
        }

        /// <summary>Field number for the "upper" field.</summary>
        public const int UpperFieldNumber = 4;
        private Timing upper_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timing Upper
        {
            get { return upper_; }
            set
            {
                upper_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TimeInterval);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TimeInterval other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (IsLeftOpen != other.IsLeftOpen) return false;
            if (!object.Equals(Lower, other.Lower)) return false;
            if (IsRightOpen != other.IsRightOpen) return false;
            if (!object.Equals(Upper, other.Upper)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (IsLeftOpen != false) hash ^= IsLeftOpen.GetHashCode();
            if (lower_ != null) hash ^= Lower.GetHashCode();
            if (IsRightOpen != false) hash ^= IsRightOpen.GetHashCode();
            if (upper_ != null) hash ^= Upper.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (IsLeftOpen != false)
            {
                output.WriteRawTag(8);
                output.WriteBool(IsLeftOpen);
            }
            if (lower_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Lower);
            }
            if (IsRightOpen != false)
            {
                output.WriteRawTag(24);
                output.WriteBool(IsRightOpen);
            }
            if (upper_ != null)
            {
                output.WriteRawTag(34);
                output.WriteMessage(Upper);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (IsLeftOpen != false)
            {
                size += 1 + 1;
            }
            if (lower_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lower);
            }
            if (IsRightOpen != false)
            {
                size += 1 + 1;
            }
            if (upper_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Upper);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TimeInterval other)
        {
            if (other == null)
            {
                return;
            }
            if (other.IsLeftOpen != false)
            {
                IsLeftOpen = other.IsLeftOpen;
            }
            if (other.lower_ != null)
            {
                if (lower_ == null)
                {
                    lower_ = new Timing();
                }
                Lower.MergeFrom(other.Lower);
            }
            if (other.IsRightOpen != false)
            {
                IsRightOpen = other.IsRightOpen;
            }
            if (other.upper_ != null)
            {
                if (upper_ == null)
                {
                    upper_ = new Timing();
                }
                Upper.MergeFrom(other.Upper);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 8:
                        {
                            IsLeftOpen = input.ReadBool();
                            break;
                        }
                    case 18:
                        {
                            if (lower_ == null)
                            {
                                lower_ = new Timing();
                            }
                            input.ReadMessage(lower_);
                            break;
                        }
                    case 24:
                        {
                            IsRightOpen = input.ReadBool();
                            break;
                        }
                    case 34:
                        {
                            if (upper_ == null)
                            {
                                upper_ = new Timing();
                            }
                            input.ReadMessage(upper_);
                            break;
                        }
                }
            }
        }

    }

    public sealed partial class Duration : pb::IMessage<Duration>
    {
        private static readonly pb::MessageParser<Duration> _parser = new pb::MessageParser<Duration>(() => new Duration());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Duration> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[15]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Duration()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Duration(Duration other) : this()
        {
            controllableInBounds_ = other.controllableInBounds_ != null ? other.controllableInBounds_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Duration Clone()
        {
            return new Duration(this);
        }

        /// <summary>Field number for the "controllable_in_bounds" field.</summary>
        public const int ControllableInBoundsFieldNumber = 1;
        private Interval controllableInBounds_;
        /// <summary>
        //// The duration of the action can be freely chosen within the indicated bounds
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Interval ControllableInBounds
        {
            get { return controllableInBounds_; }
            set
            {
                controllableInBounds_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Duration);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Duration other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(ControllableInBounds, other.ControllableInBounds)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (controllableInBounds_ != null) hash ^= ControllableInBounds.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (controllableInBounds_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(ControllableInBounds);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (controllableInBounds_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(ControllableInBounds);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Duration other)
        {
            if (other == null)
            {
                return;
            }
            if (other.controllableInBounds_ != null)
            {
                if (controllableInBounds_ == null)
                {
                    controllableInBounds_ = new Interval();
                }
                ControllableInBounds.MergeFrom(other.ControllableInBounds);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (controllableInBounds_ == null)
                            {
                                controllableInBounds_ = new Interval();
                            }
                            input.ReadMessage(controllableInBounds_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Declares an abstract task together with its expected parameters.
    ///
    /// Example: goto(robot: Robot, destination: Location)
    /// </summary>
    public sealed partial class AbstractTaskDeclaration : pb::IMessage<AbstractTaskDeclaration>
    {
        private static readonly pb::MessageParser<AbstractTaskDeclaration> _parser = new pb::MessageParser<AbstractTaskDeclaration>(() => new AbstractTaskDeclaration());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AbstractTaskDeclaration> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[16]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AbstractTaskDeclaration()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AbstractTaskDeclaration(AbstractTaskDeclaration other) : this()
        {
            name_ = other.name_;
            parameters_ = other.parameters_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AbstractTaskDeclaration Clone()
        {
            return new AbstractTaskDeclaration(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Example: "goto"
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "parameters" field.</summary>
        public const int ParametersFieldNumber = 2;
        private static readonly pb::FieldCodec<Parameter> _repeated_parameters_codec
            = pb::FieldCodec.ForMessage(18, Parameter.Parser);
        private readonly pbc::RepeatedField<Parameter> parameters_ = new pbc::RepeatedField<Parameter>();
        /// <summary>
        /// Example:
        ///  - robot: Robot
        ///  - destination: Location
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Parameter> Parameters
        {
            get { return parameters_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as AbstractTaskDeclaration);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AbstractTaskDeclaration other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (!parameters_.Equals(other.parameters_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Name.Length != 0) hash ^= Name.GetHashCode();
            hash ^= parameters_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Name.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            parameters_.WriteTo(output, _repeated_parameters_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Name.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            size += parameters_.CalculateSize(_repeated_parameters_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AbstractTaskDeclaration other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Name.Length != 0)
            {
                Name = other.Name;
            }
            parameters_.Add(other.parameters_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Representation of an abstract or primitive task that should be achieved,
    /// required either in the initial task network or as a subtask of a method.
    ///
    /// Example:  task of sending a `robot` to the KITCHEN
    ///   - t1: goto(robot, KITCHEN)
    /// </summary>
    public sealed partial class Task : pb::IMessage<Task>
    {
        private static readonly pb::MessageParser<Task> _parser = new pb::MessageParser<Task>(() => new Task());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Task> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[17]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Task()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Task(Task other) : this()
        {
            id_ = other.id_;
            taskName_ = other.taskName_;
            parameters_ = other.parameters_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Task Clone()
        {
            return new Task(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private string id_ = "";
        /// <summary>
        /// Identifier of the task, required to be unique in the method/task-network where the task appears.
        /// The `id` is notably used to refer to the start/end of the task.
        ///
        /// Example: t1
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Id
        {
            get { return id_; }
            set
            {
                id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "task_name" field.</summary>
        public const int TaskNameFieldNumber = 2;
        private string taskName_ = "";
        /// <summary>
        /// Name of the task that should be achieved. It might either
        ///  - an abstract task if the name is the one of a task declared in the problem
        ///  - a primitive task if the name is the one of an action declared in the problem
        ///
        /// Example:
        ///  - "goto" (abstract task)
        ///  - "move" (action / primitive task)
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string TaskName
        {
            get { return taskName_; }
            set
            {
                taskName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "parameters" field.</summary>
        public const int ParametersFieldNumber = 3;
        private static readonly pb::FieldCodec<Expression> _repeated_parameters_codec
            = pb::FieldCodec.ForMessage(26, Expression.Parser);
        private readonly pbc::RepeatedField<Expression> parameters_ = new pbc::RepeatedField<Expression>();
        /// <summary>
        /// Example: (for a "goto" task)
        ///  - robot    (a parameter from an outer scope)
        ///  - KITCHEN  (a constant symbol in the problem)
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Expression> Parameters
        {
            get { return parameters_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Task);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Task other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Id != other.Id) return false;
            if (TaskName != other.TaskName) return false;
            if (!parameters_.Equals(other.parameters_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Id.Length != 0) hash ^= Id.GetHashCode();
            if (TaskName.Length != 0) hash ^= TaskName.GetHashCode();
            hash ^= parameters_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Id.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Id);
            }
            if (TaskName.Length != 0)
            {
                output.WriteRawTag(18);
                output.WriteString(TaskName);
            }
            parameters_.WriteTo(output, _repeated_parameters_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Id.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
            }
            if (TaskName.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(TaskName);
            }
            size += parameters_.CalculateSize(_repeated_parameters_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Task other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Id.Length != 0)
            {
                Id = other.Id;
            }
            if (other.TaskName.Length != 0)
            {
                TaskName = other.TaskName;
            }
            parameters_.Add(other.parameters_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Id = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            TaskName = input.ReadString();
                            break;
                        }
                    case 26:
                        {
                            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// A method describes one possible way of achieving a task.
    ///
    /// Example: A method that make a "move" action and recursively calls itself until reaching the destination.
    /// </summary>
    public sealed partial class Method : pb::IMessage<Method>
    {
        private static readonly pb::MessageParser<Method> _parser = new pb::MessageParser<Method>(() => new Method());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Method> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[18]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Method()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Method(Method other) : this()
        {
            name_ = other.name_;
            parameters_ = other.parameters_.Clone();
            achievedTask_ = other.achievedTask_ != null ? other.achievedTask_.Clone() : null;
            subtasks_ = other.subtasks_.Clone();
            constraints_ = other.constraints_.Clone();
            conditions_ = other.conditions_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Method Clone()
        {
            return new Method(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// A name that uniquely identify the method.
        /// This is mostly used for user facing output or plan validation.
        ///
        /// Example: "m-recursive-goto"
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "parameters" field.</summary>
        public const int ParametersFieldNumber = 2;
        private static readonly pb::FieldCodec<Parameter> _repeated_parameters_codec
            = pb::FieldCodec.ForMessage(18, Parameter.Parser);
        private readonly pbc::RepeatedField<Parameter> parameters_ = new pbc::RepeatedField<Parameter>();
        /// <summary>
        /// Example: [robot: Robot, source: Location, intermediate: Location, destination: Location]
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Parameter> Parameters
        {
            get { return parameters_; }
        }

        /// <summary>Field number for the "achieved_task" field.</summary>
        public const int AchievedTaskFieldNumber = 3;
        private Task achievedTask_;
        /// <summary>
        /// The task that is achieved by the method.
        /// A subset of the parameters of the method will typically be used to
        /// define the task that is achieved.
        ///
        /// Example: goto(robot, destination)
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Task AchievedTask
        {
            get { return achievedTask_; }
            set
            {
                achievedTask_ = value;
            }
        }

        /// <summary>Field number for the "subtasks" field.</summary>
        public const int SubtasksFieldNumber = 4;
        private static readonly pb::FieldCodec<Task> _repeated_subtasks_codec
            = pb::FieldCodec.ForMessage(34, Task.Parser);
        private readonly pbc::RepeatedField<Task> subtasks_ = new pbc::RepeatedField<Task>();
        /// <summary>
        /// A set of subtasks that should be achieved to carry out the method.
        /// Note that the order of subtasks is irrelevant and that any ordering constraint should be
        /// specified in the `constraints` field.
        ///
        /// Example:
        ///  - t1: (move robot source intermediate)
        ///  - t2: goto(robot destination)
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Task> Subtasks
        {
            get { return subtasks_; }
        }

        /// <summary>Field number for the "constraints" field.</summary>
        public const int ConstraintsFieldNumber = 5;
        private static readonly pb::FieldCodec<Expression> _repeated_constraints_codec
            = pb::FieldCodec.ForMessage(42, Expression.Parser);
        private readonly pbc::RepeatedField<Expression> constraints_ = new pbc::RepeatedField<Expression>();
        /// <summary>
        /// Constraints enable the definition of ordering constraints as well as constraints
        /// on the allowed instantiation of the method's parameters.
        ///
        /// Example:
        ///  - end(t1) &lt; start(t2)
        ///  - source != intermediate
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Expression> Constraints
        {
            get { return constraints_; }
        }

        /// <summary>Field number for the "conditions" field.</summary>
        public const int ConditionsFieldNumber = 6;
        private static readonly pb::FieldCodec<Condition> _repeated_conditions_codec
            = pb::FieldCodec.ForMessage(50, Condition.Parser);
        private readonly pbc::RepeatedField<Condition> conditions_ = new pbc::RepeatedField<Condition>();
        /// <summary>
        /// Conjunction of conditions that must hold for the method to be applicable.
        /// As for the conditions of actions, these can be temporally qualified to refer to intermediate timepoints.
        /// In addition to the start/end of the method, the temporal qualification might refer to the start/end of
        /// one of the subtasks using its identifier.
        ///
        /// Example:
        ///  - [start] loc(robot) == source
        ///  - [end(t1)] loc(robot) == intermediate
        ///  - [end] loc(robot) == destination
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Condition> Conditions
        {
            get { return conditions_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Method);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Method other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (!parameters_.Equals(other.parameters_)) return false;
            if (!object.Equals(AchievedTask, other.AchievedTask)) return false;
            if (!subtasks_.Equals(other.subtasks_)) return false;
            if (!constraints_.Equals(other.constraints_)) return false;
            if (!conditions_.Equals(other.conditions_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Name.Length != 0) hash ^= Name.GetHashCode();
            hash ^= parameters_.GetHashCode();
            if (achievedTask_ != null) hash ^= AchievedTask.GetHashCode();
            hash ^= subtasks_.GetHashCode();
            hash ^= constraints_.GetHashCode();
            hash ^= conditions_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Name.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            parameters_.WriteTo(output, _repeated_parameters_codec);
            if (achievedTask_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(AchievedTask);
            }
            subtasks_.WriteTo(output, _repeated_subtasks_codec);
            constraints_.WriteTo(output, _repeated_constraints_codec);
            conditions_.WriteTo(output, _repeated_conditions_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Name.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            size += parameters_.CalculateSize(_repeated_parameters_codec);
            if (achievedTask_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(AchievedTask);
            }
            size += subtasks_.CalculateSize(_repeated_subtasks_codec);
            size += constraints_.CalculateSize(_repeated_constraints_codec);
            size += conditions_.CalculateSize(_repeated_conditions_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Method other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Name.Length != 0)
            {
                Name = other.Name;
            }
            parameters_.Add(other.parameters_);
            if (other.achievedTask_ != null)
            {
                if (achievedTask_ == null)
                {
                    achievedTask_ = new Task();
                }
                AchievedTask.MergeFrom(other.AchievedTask);
            }
            subtasks_.Add(other.subtasks_);
            constraints_.Add(other.constraints_);
            conditions_.Add(other.conditions_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
                            break;
                        }
                    case 26:
                        {
                            if (achievedTask_ == null)
                            {
                                achievedTask_ = new Task();
                            }
                            input.ReadMessage(achievedTask_);
                            break;
                        }
                    case 34:
                        {
                            subtasks_.AddEntriesFrom(input, _repeated_subtasks_codec);
                            break;
                        }
                    case 42:
                        {
                            constraints_.AddEntriesFrom(input, _repeated_constraints_codec);
                            break;
                        }
                    case 50:
                        {
                            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// A task network defines a set of subtasks and associated constraints.
    /// It is intended to be used to define the initial task network of the hierarchical problem.
    ///
    /// Example: an arbitrary robot should go to the KITCHEN before time 100
    /// </summary>
    public sealed partial class TaskNetwork : pb::IMessage<TaskNetwork>
    {
        private static readonly pb::MessageParser<TaskNetwork> _parser = new pb::MessageParser<TaskNetwork>(() => new TaskNetwork());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TaskNetwork> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[19]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TaskNetwork()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TaskNetwork(TaskNetwork other) : this()
        {
            variables_ = other.variables_.Clone();
            subtasks_ = other.subtasks_.Clone();
            constraints_ = other.constraints_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TaskNetwork Clone()
        {
            return new TaskNetwork(this);
        }

        /// <summary>Field number for the "variables" field.</summary>
        public const int VariablesFieldNumber = 1;
        private static readonly pb::FieldCodec<Parameter> _repeated_variables_codec
            = pb::FieldCodec.ForMessage(10, Parameter.Parser);
        private readonly pbc::RepeatedField<Parameter> variables_ = new pbc::RepeatedField<Parameter>();
        /// <summary>
        /// robot: Location
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Parameter> Variables
        {
            get { return variables_; }
        }

        /// <summary>Field number for the "subtasks" field.</summary>
        public const int SubtasksFieldNumber = 2;
        private static readonly pb::FieldCodec<Task> _repeated_subtasks_codec
            = pb::FieldCodec.ForMessage(18, Task.Parser);
        private readonly pbc::RepeatedField<Task> subtasks_ = new pbc::RepeatedField<Task>();
        /// <summary>
        /// t1: goto(robot, KITCHEN)
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Task> Subtasks
        {
            get { return subtasks_; }
        }

        /// <summary>Field number for the "constraints" field.</summary>
        public const int ConstraintsFieldNumber = 3;
        private static readonly pb::FieldCodec<Expression> _repeated_constraints_codec
            = pb::FieldCodec.ForMessage(26, Expression.Parser);
        private readonly pbc::RepeatedField<Expression> constraints_ = new pbc::RepeatedField<Expression>();
        /// <summary>
        /// end(t1) &lt;= 100
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Expression> Constraints
        {
            get { return constraints_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TaskNetwork);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TaskNetwork other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!variables_.Equals(other.variables_)) return false;
            if (!subtasks_.Equals(other.subtasks_)) return false;
            if (!constraints_.Equals(other.constraints_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= variables_.GetHashCode();
            hash ^= subtasks_.GetHashCode();
            hash ^= constraints_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            variables_.WriteTo(output, _repeated_variables_codec);
            subtasks_.WriteTo(output, _repeated_subtasks_codec);
            constraints_.WriteTo(output, _repeated_constraints_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += variables_.CalculateSize(_repeated_variables_codec);
            size += subtasks_.CalculateSize(_repeated_subtasks_codec);
            size += constraints_.CalculateSize(_repeated_constraints_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TaskNetwork other)
        {
            if (other == null)
            {
                return;
            }
            variables_.Add(other.variables_);
            subtasks_.Add(other.subtasks_);
            constraints_.Add(other.constraints_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            variables_.AddEntriesFrom(input, _repeated_variables_codec);
                            break;
                        }
                    case 18:
                        {
                            subtasks_.AddEntriesFrom(input, _repeated_subtasks_codec);
                            break;
                        }
                    case 26:
                        {
                            constraints_.AddEntriesFrom(input, _repeated_constraints_codec);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Represents the hierarchical part of a problem.
    /// features: hierarchical
    /// </summary>
    public sealed partial class Hierarchy : pb::IMessage<Hierarchy>
    {
        private static readonly pb::MessageParser<Hierarchy> _parser = new pb::MessageParser<Hierarchy>(() => new Hierarchy());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Hierarchy> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[20]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Hierarchy()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Hierarchy(Hierarchy other) : this()
        {
            abstractTasks_ = other.abstractTasks_.Clone();
            methods_ = other.methods_.Clone();
            initialTaskNetwork_ = other.initialTaskNetwork_ != null ? other.initialTaskNetwork_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Hierarchy Clone()
        {
            return new Hierarchy(this);
        }

        /// <summary>Field number for the "abstract_tasks" field.</summary>
        public const int AbstractTasksFieldNumber = 1;
        private static readonly pb::FieldCodec<AbstractTaskDeclaration> _repeated_abstractTasks_codec
            = pb::FieldCodec.ForMessage(10, AbstractTaskDeclaration.Parser);
        private readonly pbc::RepeatedField<AbstractTaskDeclaration> abstractTasks_ = new pbc::RepeatedField<AbstractTaskDeclaration>();
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<AbstractTaskDeclaration> AbstractTasks
        {
            get { return abstractTasks_; }
        }

        /// <summary>Field number for the "methods" field.</summary>
        public const int MethodsFieldNumber = 2;
        private static readonly pb::FieldCodec<Method> _repeated_methods_codec
            = pb::FieldCodec.ForMessage(18, Method.Parser);
        private readonly pbc::RepeatedField<Method> methods_ = new pbc::RepeatedField<Method>();
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Method> Methods
        {
            get { return methods_; }
        }

        /// <summary>Field number for the "initial_task_network" field.</summary>
        public const int InitialTaskNetworkFieldNumber = 3;
        private TaskNetwork initialTaskNetwork_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TaskNetwork InitialTaskNetwork
        {
            get { return initialTaskNetwork_; }
            set
            {
                initialTaskNetwork_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Hierarchy);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Hierarchy other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!abstractTasks_.Equals(other.abstractTasks_)) return false;
            if (!methods_.Equals(other.methods_)) return false;
            if (!object.Equals(InitialTaskNetwork, other.InitialTaskNetwork)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= abstractTasks_.GetHashCode();
            hash ^= methods_.GetHashCode();
            if (initialTaskNetwork_ != null) hash ^= InitialTaskNetwork.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            abstractTasks_.WriteTo(output, _repeated_abstractTasks_codec);
            methods_.WriteTo(output, _repeated_methods_codec);
            if (initialTaskNetwork_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(InitialTaskNetwork);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += abstractTasks_.CalculateSize(_repeated_abstractTasks_codec);
            size += methods_.CalculateSize(_repeated_methods_codec);
            if (initialTaskNetwork_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitialTaskNetwork);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Hierarchy other)
        {
            if (other == null)
            {
                return;
            }
            abstractTasks_.Add(other.abstractTasks_);
            methods_.Add(other.methods_);
            if (other.initialTaskNetwork_ != null)
            {
                if (initialTaskNetwork_ == null)
                {
                    initialTaskNetwork_ = new TaskNetwork();
                }
                InitialTaskNetwork.MergeFrom(other.InitialTaskNetwork);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            abstractTasks_.AddEntriesFrom(input, _repeated_abstractTasks_codec);
                            break;
                        }
                    case 18:
                        {
                            methods_.AddEntriesFrom(input, _repeated_methods_codec);
                            break;
                        }
                    case 26:
                        {
                            if (initialTaskNetwork_ == null)
                            {
                                initialTaskNetwork_ = new TaskNetwork();
                            }
                            input.ReadMessage(initialTaskNetwork_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Activity in a scheduling problem.
    /// </summary>
    public sealed partial class Activity : pb::IMessage<Activity>
    {
        private static readonly pb::MessageParser<Activity> _parser = new pb::MessageParser<Activity>(() => new Activity());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Activity> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[21]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Activity()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Activity(Activity other) : this()
        {
            name_ = other.name_;
            parameters_ = other.parameters_.Clone();
            duration_ = other.duration_ != null ? other.duration_.Clone() : null;
            conditions_ = other.conditions_.Clone();
            effects_ = other.effects_.Clone();
            constraints_ = other.constraints_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Activity Clone()
        {
            return new Activity(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Name of the activity that must uniquely identify it.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "parameters" field.</summary>
        public const int ParametersFieldNumber = 2;
        private static readonly pb::FieldCodec<Parameter> _repeated_parameters_codec
            = pb::FieldCodec.ForMessage(18, Parameter.Parser);
        private readonly pbc::RepeatedField<Parameter> parameters_ = new pbc::RepeatedField<Parameter>();
        /// <summary>
        /// Typed and named parameters of the activity.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Parameter> Parameters
        {
            get { return parameters_; }
        }

        /// <summary>Field number for the "duration" field.</summary>
        public const int DurationFieldNumber = 3;
        private Duration duration_;
        /// <summary>
        /// Duration of the activity
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Duration Duration
        {
            get { return duration_; }
            set
            {
                duration_ = value;
            }
        }

        /// <summary>Field number for the "conditions" field.</summary>
        public const int ConditionsFieldNumber = 4;
        private static readonly pb::FieldCodec<Condition> _repeated_conditions_codec
            = pb::FieldCodec.ForMessage(34, Condition.Parser);
        private readonly pbc::RepeatedField<Condition> conditions_ = new pbc::RepeatedField<Condition>();
        /// <summary>
        /// Conjunction of conditions that must hold if the activity is present.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Condition> Conditions
        {
            get { return conditions_; }
        }

        /// <summary>Field number for the "effects" field.</summary>
        public const int EffectsFieldNumber = 5;
        private static readonly pb::FieldCodec<Effect> _repeated_effects_codec
            = pb::FieldCodec.ForMessage(42, Effect.Parser);
        private readonly pbc::RepeatedField<Effect> effects_ = new pbc::RepeatedField<Effect>();
        /// <summary>
        /// Conjunction of effects that this activity produces.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Effect> Effects
        {
            get { return effects_; }
        }

        /// <summary>Field number for the "constraints" field.</summary>
        public const int ConstraintsFieldNumber = 6;
        private static readonly pb::FieldCodec<Expression> _repeated_constraints_codec
            = pb::FieldCodec.ForMessage(50, Expression.Parser);
        private readonly pbc::RepeatedField<Expression> constraints_ = new pbc::RepeatedField<Expression>();
        /// <summary>
        /// Conjunction of static constraints that must hold if the activity is present.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Expression> Constraints
        {
            get { return constraints_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Activity);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Activity other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            if (!parameters_.Equals(other.parameters_)) return false;
            if (!object.Equals(Duration, other.Duration)) return false;
            if (!conditions_.Equals(other.conditions_)) return false;
            if (!effects_.Equals(other.effects_)) return false;
            if (!constraints_.Equals(other.constraints_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Name.Length != 0) hash ^= Name.GetHashCode();
            hash ^= parameters_.GetHashCode();
            if (duration_ != null) hash ^= Duration.GetHashCode();
            hash ^= conditions_.GetHashCode();
            hash ^= effects_.GetHashCode();
            hash ^= constraints_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Name.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            parameters_.WriteTo(output, _repeated_parameters_codec);
            if (duration_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(Duration);
            }
            conditions_.WriteTo(output, _repeated_conditions_codec);
            effects_.WriteTo(output, _repeated_effects_codec);
            constraints_.WriteTo(output, _repeated_constraints_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Name.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            size += parameters_.CalculateSize(_repeated_parameters_codec);
            if (duration_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Duration);
            }
            size += conditions_.CalculateSize(_repeated_conditions_codec);
            size += effects_.CalculateSize(_repeated_effects_codec);
            size += constraints_.CalculateSize(_repeated_constraints_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Activity other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Name.Length != 0)
            {
                Name = other.Name;
            }
            parameters_.Add(other.parameters_);
            if (other.duration_ != null)
            {
                if (duration_ == null)
                {
                    duration_ = new Duration();
                }
                Duration.MergeFrom(other.Duration);
            }
            conditions_.Add(other.conditions_);
            effects_.Add(other.effects_);
            constraints_.Add(other.constraints_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
                            break;
                        }
                    case 26:
                        {
                            if (duration_ == null)
                            {
                                duration_ = new Duration();
                            }
                            input.ReadMessage(duration_);
                            break;
                        }
                    case 34:
                        {
                            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
                            break;
                        }
                    case 42:
                        {
                            effects_.AddEntriesFrom(input, _repeated_effects_codec);
                            break;
                        }
                    case 50:
                        {
                            constraints_.AddEntriesFrom(input, _repeated_constraints_codec);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Extension of `Problem` for scheduling
    /// </summary>
    public sealed partial class SchedulingExtension : pb::IMessage<SchedulingExtension>
    {
        private static readonly pb::MessageParser<SchedulingExtension> _parser = new pb::MessageParser<SchedulingExtension>(() => new SchedulingExtension());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SchedulingExtension> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[22]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SchedulingExtension()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SchedulingExtension(SchedulingExtension other) : this()
        {
            activities_ = other.activities_.Clone();
            variables_ = other.variables_.Clone();
            constraints_ = other.constraints_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SchedulingExtension Clone()
        {
            return new SchedulingExtension(this);
        }

        /// <summary>Field number for the "activities" field.</summary>
        public const int ActivitiesFieldNumber = 1;
        private static readonly pb::FieldCodec<Activity> _repeated_activities_codec
            = pb::FieldCodec.ForMessage(10, Activity.Parser);
        private readonly pbc::RepeatedField<Activity> activities_ = new pbc::RepeatedField<Activity>();
        /// <summary>
        /// All potential activities of the scheduling problem.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Activity> Activities
        {
            get { return activities_; }
        }

        /// <summary>Field number for the "variables" field.</summary>
        public const int VariablesFieldNumber = 2;
        private static readonly pb::FieldCodec<Parameter> _repeated_variables_codec
            = pb::FieldCodec.ForMessage(18, Parameter.Parser);
        private readonly pbc::RepeatedField<Parameter> variables_ = new pbc::RepeatedField<Parameter>();
        /// <summary>
        /// All variables in the base problem
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Parameter> Variables
        {
            get { return variables_; }
        }

        /// <summary>Field number for the "constraints" field.</summary>
        public const int ConstraintsFieldNumber = 5;
        private static readonly pb::FieldCodec<Expression> _repeated_constraints_codec
            = pb::FieldCodec.ForMessage(42, Expression.Parser);
        private readonly pbc::RepeatedField<Expression> constraints_ = new pbc::RepeatedField<Expression>();
        /// <summary>
        /// All constraints in the base problem.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Expression> Constraints
        {
            get { return constraints_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as SchedulingExtension);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SchedulingExtension other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!activities_.Equals(other.activities_)) return false;
            if (!variables_.Equals(other.variables_)) return false;
            if (!constraints_.Equals(other.constraints_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= activities_.GetHashCode();
            hash ^= variables_.GetHashCode();
            hash ^= constraints_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            activities_.WriteTo(output, _repeated_activities_codec);
            variables_.WriteTo(output, _repeated_variables_codec);
            constraints_.WriteTo(output, _repeated_constraints_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += activities_.CalculateSize(_repeated_activities_codec);
            size += variables_.CalculateSize(_repeated_variables_codec);
            size += constraints_.CalculateSize(_repeated_constraints_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SchedulingExtension other)
        {
            if (other == null)
            {
                return;
            }
            activities_.Add(other.activities_);
            variables_.Add(other.variables_);
            constraints_.Add(other.constraints_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            activities_.AddEntriesFrom(input, _repeated_activities_codec);
                            break;
                        }
                    case 18:
                        {
                            variables_.AddEntriesFrom(input, _repeated_variables_codec);
                            break;
                        }
                    case 42:
                        {
                            constraints_.AddEntriesFrom(input, _repeated_constraints_codec);
                            break;
                        }
                }
            }
        }

    }

    public sealed partial class Schedule : pb::IMessage<Schedule>
    {
        private static readonly pb::MessageParser<Schedule> _parser = new pb::MessageParser<Schedule>(() => new Schedule());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Schedule> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[23]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Schedule()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Schedule(Schedule other) : this()
        {
            activities_ = other.activities_.Clone();
            variableAssignments_ = other.variableAssignments_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Schedule Clone()
        {
            return new Schedule(this);
        }

        /// <summary>Field number for the "activities" field.</summary>
        public const int ActivitiesFieldNumber = 1;
        private static readonly pb::FieldCodec<string> _repeated_activities_codec
            = pb::FieldCodec.ForString(10);
        private readonly pbc::RepeatedField<string> activities_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Name of the activities that appear in the solution
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> Activities
        {
            get { return activities_; }
        }

        /// <summary>Field number for the "variable_assignments" field.</summary>
        public const int VariableAssignmentsFieldNumber = 2;
        private static readonly pbc::MapField<string, Atom>.Codec _map_variableAssignments_codec
            = new pbc::MapField<string, Atom>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, Atom.Parser), 18);
        private readonly pbc::MapField<string, Atom> variableAssignments_ = new pbc::MapField<string, Atom>();
        /// <summary>
        /// Assignment of all variables and activity parameters and timepoints
        /// that appear in the solution.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, Atom> VariableAssignments
        {
            get { return variableAssignments_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Schedule);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Schedule other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!activities_.Equals(other.activities_)) return false;
            if (!VariableAssignments.Equals(other.VariableAssignments)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= activities_.GetHashCode();
            hash ^= VariableAssignments.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            activities_.WriteTo(output, _repeated_activities_codec);
            variableAssignments_.WriteTo(output, _map_variableAssignments_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += activities_.CalculateSize(_repeated_activities_codec);
            size += variableAssignments_.CalculateSize(_map_variableAssignments_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Schedule other)
        {
            if (other == null)
            {
                return;
            }
            activities_.Add(other.activities_);
            variableAssignments_.Add(other.variableAssignments_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            activities_.AddEntriesFrom(input, _repeated_activities_codec);
                            break;
                        }
                    case 18:
                        {
                            variableAssignments_.AddEntriesFrom(input, _map_variableAssignments_codec);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// A Goal is currently an expression that must hold either:
    /// - in the final state,
    /// - over a specific temporal interval (under the `timed_goals` features)
    /// </summary>
    public sealed partial class Goal : pb::IMessage<Goal>
    {
        private static readonly pb::MessageParser<Goal> _parser = new pb::MessageParser<Goal>(() => new Goal());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Goal> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[24]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Goal()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Goal(Goal other) : this()
        {
            goal_ = other.goal_ != null ? other.goal_.Clone() : null;
            timing_ = other.timing_ != null ? other.timing_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Goal Clone()
        {
            return new Goal(this);
        }

        /// <summary>Field number for the "goal" field.</summary>
        public const int Goal_FieldNumber = 1;
        private Expression goal_;
        /// <summary>
        /// Goal expression that must hold in the final state.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Goal_
        {
            get { return goal_; }
            set
            {
                goal_ = value;
            }
        }

        /// <summary>Field number for the "timing" field.</summary>
        public const int TimingFieldNumber = 2;
        private TimeInterval timing_;
        /// <summary>
        /// Optional. If specified the goal should hold over the specified temporal interval (instead of on the final state).
        /// features: TIMED_GOALS
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeInterval Timing
        {
            get { return timing_; }
            set
            {
                timing_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Goal);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Goal other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Goal_, other.Goal_)) return false;
            if (!object.Equals(Timing, other.Timing)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (goal_ != null) hash ^= Goal_.GetHashCode();
            if (timing_ != null) hash ^= Timing.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (goal_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Goal_);
            }
            if (timing_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Timing);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (goal_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Goal_);
            }
            if (timing_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timing);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Goal other)
        {
            if (other == null)
            {
                return;
            }
            if (other.goal_ != null)
            {
                if (goal_ == null)
                {
                    goal_ = new Expression();
                }
                Goal_.MergeFrom(other.Goal_);
            }
            if (other.timing_ != null)
            {
                if (timing_ == null)
                {
                    timing_ = new TimeInterval();
                }
                Timing.MergeFrom(other.Timing);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (goal_ == null)
                            {
                                goal_ = new Expression();
                            }
                            input.ReadMessage(goal_);
                            break;
                        }
                    case 18:
                        {
                            if (timing_ == null)
                            {
                                timing_ = new TimeInterval();
                            }
                            input.ReadMessage(timing_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Represents an effect that will occur sometime beyond the initial state. (similar to timed initial literals)
    /// </summary>
    public sealed partial class TimedEffect : pb::IMessage<TimedEffect>
    {
        private static readonly pb::MessageParser<TimedEffect> _parser = new pb::MessageParser<TimedEffect>(() => new TimedEffect());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TimedEffect> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[25]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimedEffect()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimedEffect(TimedEffect other) : this()
        {
            effect_ = other.effect_ != null ? other.effect_.Clone() : null;
            occurrenceTime_ = other.occurrenceTime_ != null ? other.occurrenceTime_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimedEffect Clone()
        {
            return new TimedEffect(this);
        }

        /// <summary>Field number for the "effect" field.</summary>
        public const int EffectFieldNumber = 1;
        private EffectExpression effect_;
        /// <summary>
        /// Required. An effect expression that will take place sometime in the future (i.e. not at the intial state) as specified by the temporal qualifiation.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EffectExpression Effect
        {
            get { return effect_; }
            set
            {
                effect_ = value;
            }
        }

        /// <summary>Field number for the "occurrence_time" field.</summary>
        public const int OccurrenceTimeFieldNumber = 2;
        private Timing occurrenceTime_;
        /// <summary>
        /// Required. Temporal qualification denoting when the timed fact will occur.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Timing OccurrenceTime
        {
            get { return occurrenceTime_; }
            set
            {
                occurrenceTime_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TimedEffect);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TimedEffect other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Effect, other.Effect)) return false;
            if (!object.Equals(OccurrenceTime, other.OccurrenceTime)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (effect_ != null) hash ^= Effect.GetHashCode();
            if (occurrenceTime_ != null) hash ^= OccurrenceTime.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (effect_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Effect);
            }
            if (occurrenceTime_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(OccurrenceTime);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (effect_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Effect);
            }
            if (occurrenceTime_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(OccurrenceTime);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TimedEffect other)
        {
            if (other == null)
            {
                return;
            }
            if (other.effect_ != null)
            {
                if (effect_ == null)
                {
                    effect_ = new EffectExpression();
                }
                Effect.MergeFrom(other.Effect);
            }
            if (other.occurrenceTime_ != null)
            {
                if (occurrenceTime_ == null)
                {
                    occurrenceTime_ = new Timing();
                }
                OccurrenceTime.MergeFrom(other.OccurrenceTime);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (effect_ == null)
                            {
                                effect_ = new EffectExpression();
                            }
                            input.ReadMessage(effect_);
                            break;
                        }
                    case 18:
                        {
                            if (occurrenceTime_ == null)
                            {
                                occurrenceTime_ = new Timing();
                            }
                            input.ReadMessage(occurrenceTime_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// An assignment of a value to a fluent, as it appears in the initial state definition.
    /// </summary>
    public sealed partial class Assignment : pb::IMessage<Assignment>
    {
        private static readonly pb::MessageParser<Assignment> _parser = new pb::MessageParser<Assignment>(() => new Assignment());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Assignment> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[26]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Assignment()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Assignment(Assignment other) : this()
        {
            fluent_ = other.fluent_ != null ? other.fluent_.Clone() : null;
            value_ = other.value_ != null ? other.value_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Assignment Clone()
        {
            return new Assignment(this);
        }

        /// <summary>Field number for the "fluent" field.</summary>
        public const int FluentFieldNumber = 1;
        private Expression fluent_;
        /// <summary>
        /// State variable that is assigned the `value`.
        /// It should be an expression of the STATE_VARIABLE kind for which all parameters are of the CONSTANT kind.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Fluent
        {
            get { return fluent_; }
            set
            {
                fluent_ = value;
            }
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 2;
        private Expression value_;
        /// <summary>
        /// An expression of the CONSTANT kind, denoting the value take by the state variable.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Value
        {
            get { return value_; }
            set
            {
                value_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Assignment);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Assignment other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Fluent, other.Fluent)) return false;
            if (!object.Equals(Value, other.Value)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (fluent_ != null) hash ^= Fluent.GetHashCode();
            if (value_ != null) hash ^= Value.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (fluent_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Fluent);
            }
            if (value_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Value);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (fluent_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Fluent);
            }
            if (value_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Value);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Assignment other)
        {
            if (other == null)
            {
                return;
            }
            if (other.fluent_ != null)
            {
                if (fluent_ == null)
                {
                    fluent_ = new Expression();
                }
                Fluent.MergeFrom(other.Fluent);
            }
            if (other.value_ != null)
            {
                if (value_ == null)
                {
                    value_ = new Expression();
                }
                Value.MergeFrom(other.Value);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (fluent_ == null)
                            {
                                fluent_ = new Expression();
                            }
                            input.ReadMessage(fluent_);
                            break;
                        }
                    case 18:
                        {
                            if (value_ == null)
                            {
                                value_ = new Expression();
                            }
                            input.ReadMessage(value_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Represents a goal associated with a weight, used to define oversubscription planning.
    /// </summary>
    public sealed partial class GoalWithWeight : pb::IMessage<GoalWithWeight>
    {
        private static readonly pb::MessageParser<GoalWithWeight> _parser = new pb::MessageParser<GoalWithWeight>(() => new GoalWithWeight());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<GoalWithWeight> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[27]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public GoalWithWeight()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public GoalWithWeight(GoalWithWeight other) : this()
        {
            goal_ = other.goal_ != null ? other.goal_.Clone() : null;
            weight_ = other.weight_ != null ? other.weight_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public GoalWithWeight Clone()
        {
            return new GoalWithWeight(this);
        }

        /// <summary>Field number for the "goal" field.</summary>
        public const int GoalFieldNumber = 1;
        private Expression goal_;
        /// <summary>
        /// Goal expression
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Goal
        {
            get { return goal_; }
            set
            {
                goal_ = value;
            }
        }

        /// <summary>Field number for the "weight" field.</summary>
        public const int WeightFieldNumber = 2;
        private Real weight_;
        /// <summary>
        /// The weight
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Real Weight
        {
            get { return weight_; }
            set
            {
                weight_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as GoalWithWeight);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(GoalWithWeight other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Goal, other.Goal)) return false;
            if (!object.Equals(Weight, other.Weight)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (goal_ != null) hash ^= Goal.GetHashCode();
            if (weight_ != null) hash ^= Weight.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (goal_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Goal);
            }
            if (weight_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Weight);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (goal_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Goal);
            }
            if (weight_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Weight);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(GoalWithWeight other)
        {
            if (other == null)
            {
                return;
            }
            if (other.goal_ != null)
            {
                if (goal_ == null)
                {
                    goal_ = new Expression();
                }
                Goal.MergeFrom(other.Goal);
            }
            if (other.weight_ != null)
            {
                if (weight_ == null)
                {
                    weight_ = new Real();
                }
                Weight.MergeFrom(other.Weight);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (goal_ == null)
                            {
                                goal_ = new Expression();
                            }
                            input.ReadMessage(goal_);
                            break;
                        }
                    case 18:
                        {
                            if (weight_ == null)
                            {
                                weight_ = new Real();
                            }
                            input.ReadMessage(weight_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Represents a timed goal associated with a weight, used to define temporal oversubscription planning.
    /// </summary>
    public sealed partial class TimedGoalWithWeight : pb::IMessage<TimedGoalWithWeight>
    {
        private static readonly pb::MessageParser<TimedGoalWithWeight> _parser = new pb::MessageParser<TimedGoalWithWeight>(() => new TimedGoalWithWeight());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TimedGoalWithWeight> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[28]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimedGoalWithWeight()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimedGoalWithWeight(TimedGoalWithWeight other) : this()
        {
            goal_ = other.goal_ != null ? other.goal_.Clone() : null;
            timing_ = other.timing_ != null ? other.timing_.Clone() : null;
            weight_ = other.weight_ != null ? other.weight_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimedGoalWithWeight Clone()
        {
            return new TimedGoalWithWeight(this);
        }

        /// <summary>Field number for the "goal" field.</summary>
        public const int GoalFieldNumber = 1;
        private Expression goal_;
        /// <summary>
        /// Goal expression
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Goal
        {
            get { return goal_; }
            set
            {
                goal_ = value;
            }
        }

        /// <summary>Field number for the "timing" field.</summary>
        public const int TimingFieldNumber = 2;
        private TimeInterval timing_;
        /// <summary>
        /// The time interval
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeInterval Timing
        {
            get { return timing_; }
            set
            {
                timing_ = value;
            }
        }

        /// <summary>Field number for the "weight" field.</summary>
        public const int WeightFieldNumber = 3;
        private Real weight_;
        /// <summary>
        /// The weight
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Real Weight
        {
            get { return weight_; }
            set
            {
                weight_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as TimedGoalWithWeight);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TimedGoalWithWeight other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Goal, other.Goal)) return false;
            if (!object.Equals(Timing, other.Timing)) return false;
            if (!object.Equals(Weight, other.Weight)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (goal_ != null) hash ^= Goal.GetHashCode();
            if (timing_ != null) hash ^= Timing.GetHashCode();
            if (weight_ != null) hash ^= Weight.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (goal_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Goal);
            }
            if (timing_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Timing);
            }
            if (weight_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(Weight);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (goal_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Goal);
            }
            if (timing_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timing);
            }
            if (weight_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Weight);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TimedGoalWithWeight other)
        {
            if (other == null)
            {
                return;
            }
            if (other.goal_ != null)
            {
                if (goal_ == null)
                {
                    goal_ = new Expression();
                }
                Goal.MergeFrom(other.Goal);
            }
            if (other.timing_ != null)
            {
                if (timing_ == null)
                {
                    timing_ = new TimeInterval();
                }
                Timing.MergeFrom(other.Timing);
            }
            if (other.weight_ != null)
            {
                if (weight_ == null)
                {
                    weight_ = new Real();
                }
                Weight.MergeFrom(other.Weight);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (goal_ == null)
                            {
                                goal_ = new Expression();
                            }
                            input.ReadMessage(goal_);
                            break;
                        }
                    case 18:
                        {
                            if (timing_ == null)
                            {
                                timing_ = new TimeInterval();
                            }
                            input.ReadMessage(timing_);
                            break;
                        }
                    case 26:
                        {
                            if (weight_ == null)
                            {
                                weight_ = new Real();
                            }
                            input.ReadMessage(weight_);
                            break;
                        }
                }
            }
        }

    }

    public sealed partial class Metric : pb::IMessage<Metric>
    {
        private static readonly pb::MessageParser<Metric> _parser = new pb::MessageParser<Metric>(() => new Metric());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Metric> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[29]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Metric()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Metric(Metric other) : this()
        {
            kind_ = other.kind_;
            expression_ = other.expression_ != null ? other.expression_.Clone() : null;
            actionCosts_ = other.actionCosts_.Clone();
            defaultActionCost_ = other.defaultActionCost_ != null ? other.defaultActionCost_.Clone() : null;
            goals_ = other.goals_.Clone();
            timedGoals_ = other.timedGoals_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Metric Clone()
        {
            return new Metric(this);
        }

        /// <summary>Field number for the "kind" field.</summary>
        public const int KindFieldNumber = 1;
        private Metric.Types.MetricKind kind_ = 0;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Metric.Types.MetricKind Kind
        {
            get { return kind_; }
            set
            {
                kind_ = value;
            }
        }

        /// <summary>Field number for the "expression" field.</summary>
        public const int ExpressionFieldNumber = 2;
        private Expression expression_;
        /// <summary>
        /// Expression to minimize/maximize in the final state.
        /// Empty, if the `kind` is not {MIN/MAX}IMIZE_EXPRESSION_ON_FINAL_STATE
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression Expression
        {
            get { return expression_; }
            set
            {
                expression_ = value;
            }
        }

        /// <summary>Field number for the "action_costs" field.</summary>
        public const int ActionCostsFieldNumber = 3;
        private static readonly pbc::MapField<string, Expression>.Codec _map_actionCosts_codec
            = new pbc::MapField<string, Expression>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, Expression.Parser), 26);
        private readonly pbc::MapField<string, Expression> actionCosts_ = new pbc::MapField<string, Expression>();
        /// <summary>
        /// If `kind == MINIMIZE_ACTION_COSTS``, then each action is associated to a cost expression.
        ///
        /// TODO: Document what is allowed in the expression. See issue #134
        /// In particular, for this metric to be useful in many practical problems, the cost expression
        /// should allow referring to the action parameters (and possibly the current state at the action start/end).
        /// This is very awkward to do in this setting where the expression is detached from its scope.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, Expression> ActionCosts
        {
            get { return actionCosts_; }
        }

        /// <summary>Field number for the "default_action_cost" field.</summary>
        public const int DefaultActionCostFieldNumber = 4;
        private Expression defaultActionCost_;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Expression DefaultActionCost
        {
            get { return defaultActionCost_; }
            set
            {
                defaultActionCost_ = value;
            }
        }

        /// <summary>Field number for the "goals" field.</summary>
        public const int GoalsFieldNumber = 5;
        private static readonly pb::FieldCodec<GoalWithWeight> _repeated_goals_codec
            = pb::FieldCodec.ForMessage(42, GoalWithWeight.Parser);
        private readonly pbc::RepeatedField<GoalWithWeight> goals_ = new pbc::RepeatedField<GoalWithWeight>();
        /// <summary>
        /// List of goals used to define the oversubscription planning problem.
        /// Empty, if the `kind` is not OVERSUBSCRIPTION
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<GoalWithWeight> Goals
        {
            get { return goals_; }
        }

        /// <summary>Field number for the "timed_goals" field.</summary>
        public const int TimedGoalsFieldNumber = 6;
        private static readonly pb::FieldCodec<TimedGoalWithWeight> _repeated_timedGoals_codec
            = pb::FieldCodec.ForMessage(50, TimedGoalWithWeight.Parser);
        private readonly pbc::RepeatedField<TimedGoalWithWeight> timedGoals_ = new pbc::RepeatedField<TimedGoalWithWeight>();
        /// <summary>
        /// List of timed goals used to define the temporal oversubscription planning problem.
        /// Empty, if the `kind` is not TEMPORAL_OVERSUBSCRIPTION
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<TimedGoalWithWeight> TimedGoals
        {
            get { return timedGoals_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Metric);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Metric other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Kind != other.Kind) return false;
            if (!object.Equals(Expression, other.Expression)) return false;
            if (!ActionCosts.Equals(other.ActionCosts)) return false;
            if (!object.Equals(DefaultActionCost, other.DefaultActionCost)) return false;
            if (!goals_.Equals(other.goals_)) return false;
            if (!timedGoals_.Equals(other.timedGoals_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Kind != 0) hash ^= Kind.GetHashCode();
            if (expression_ != null) hash ^= Expression.GetHashCode();
            hash ^= ActionCosts.GetHashCode();
            if (defaultActionCost_ != null) hash ^= DefaultActionCost.GetHashCode();
            hash ^= goals_.GetHashCode();
            hash ^= timedGoals_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Kind != 0)
            {
                output.WriteRawTag(8);
                output.WriteEnum((int)Kind);
            }
            if (expression_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Expression);
            }
            actionCosts_.WriteTo(output, _map_actionCosts_codec);
            if (defaultActionCost_ != null)
            {
                output.WriteRawTag(34);
                output.WriteMessage(DefaultActionCost);
            }
            goals_.WriteTo(output, _repeated_goals_codec);
            timedGoals_.WriteTo(output, _repeated_timedGoals_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Kind != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Kind);
            }
            if (expression_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Expression);
            }
            size += actionCosts_.CalculateSize(_map_actionCosts_codec);
            if (defaultActionCost_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultActionCost);
            }
            size += goals_.CalculateSize(_repeated_goals_codec);
            size += timedGoals_.CalculateSize(_repeated_timedGoals_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Metric other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Kind != 0)
            {
                Kind = other.Kind;
            }
            if (other.expression_ != null)
            {
                if (expression_ == null)
                {
                    expression_ = new Expression();
                }
                Expression.MergeFrom(other.Expression);
            }
            actionCosts_.Add(other.actionCosts_);
            if (other.defaultActionCost_ != null)
            {
                if (defaultActionCost_ == null)
                {
                    defaultActionCost_ = new Expression();
                }
                DefaultActionCost.MergeFrom(other.DefaultActionCost);
            }
            goals_.Add(other.goals_);
            timedGoals_.Add(other.timedGoals_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 8:
                        {
                            kind_ = (Metric.Types.MetricKind)input.ReadEnum();
                            break;
                        }
                    case 18:
                        {
                            if (expression_ == null)
                            {
                                expression_ = new Expression();
                            }
                            input.ReadMessage(expression_);
                            break;
                        }
                    case 26:
                        {
                            actionCosts_.AddEntriesFrom(input, _map_actionCosts_codec);
                            break;
                        }
                    case 34:
                        {
                            if (defaultActionCost_ == null)
                            {
                                defaultActionCost_ = new Expression();
                            }
                            input.ReadMessage(defaultActionCost_);
                            break;
                        }
                    case 42:
                        {
                            goals_.AddEntriesFrom(input, _repeated_goals_codec);
                            break;
                        }
                    case 50:
                        {
                            timedGoals_.AddEntriesFrom(input, _repeated_timedGoals_codec);
                            break;
                        }
                }
            }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Metric message type.</summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types
        {
            public enum MetricKind
            {
                /// <summary>
                /// Minimize the action costs expressed in the `action_costs` field
                /// </summary>
                [pbr::OriginalName("MINIMIZE_ACTION_COSTS")] MinimizeActionCosts = 0,
                /// <summary>
                /// Minimize the length of the resulting sequential plan
                /// </summary>
                [pbr::OriginalName("MINIMIZE_SEQUENTIAL_PLAN_LENGTH")] MinimizeSequentialPlanLength = 1,
                /// <summary>
                /// Minimize the makespan in case of temporal planning
                /// features: durative_actions
                /// </summary>
                [pbr::OriginalName("MINIMIZE_MAKESPAN")] MinimizeMakespan = 2,
                /// <summary>
                /// Minimize the value of the expression defined in the `expression` field
                /// </summary>
                [pbr::OriginalName("MINIMIZE_EXPRESSION_ON_FINAL_STATE")] MinimizeExpressionOnFinalState = 3,
                /// <summary>
                /// Maximize the value of the expression defined in the `expression` field
                /// </summary>
                [pbr::OriginalName("MAXIMIZE_EXPRESSION_ON_FINAL_STATE")] MaximizeExpressionOnFinalState = 4,
                /// <summary>
                /// Maximize the weighted number of goals reached
                /// </summary>
                [pbr::OriginalName("OVERSUBSCRIPTION")] Oversubscription = 5,
                /// <summary>
                /// Maximize the weighted number of timed goals reached
                /// </summary>
                [pbr::OriginalName("TEMPORAL_OVERSUBSCRIPTION")] TemporalOversubscription = 6,
            }

        }
        #endregion

    }

    public sealed partial class Problem : pb::IMessage<Problem>
    {
        private static readonly pb::MessageParser<Problem> _parser = new pb::MessageParser<Problem>(() => new Problem());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Problem> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[30]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Problem()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Problem(Problem other) : this()
        {
            domainName_ = other.domainName_;
            problemName_ = other.problemName_;
            types_ = other.types_.Clone();
            fluents_ = other.fluents_.Clone();
            objects_ = other.objects_.Clone();
            actions_ = other.actions_.Clone();
            initialState_ = other.initialState_.Clone();
            timedEffects_ = other.timedEffects_.Clone();
            goals_ = other.goals_.Clone();
            features_ = other.features_.Clone();
            metrics_ = other.metrics_.Clone();
            hierarchy_ = other.hierarchy_ != null ? other.hierarchy_.Clone() : null;
            schedulingExtension_ = other.schedulingExtension_ != null ? other.schedulingExtension_.Clone() : null;
            trajectoryConstraints_ = other.trajectoryConstraints_.Clone();
            discreteTime_ = other.discreteTime_;
            selfOverlapping_ = other.selfOverlapping_;
            epsilon_ = other.epsilon_ != null ? other.epsilon_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Problem Clone()
        {
            return new Problem(this);
        }

        /// <summary>Field number for the "domain_name" field.</summary>
        public const int DomainNameFieldNumber = 1;
        private string domainName_ = "";
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string DomainName
        {
            get { return domainName_; }
            set
            {
                domainName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "problem_name" field.</summary>
        public const int ProblemNameFieldNumber = 2;
        private string problemName_ = "";
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ProblemName
        {
            get { return problemName_; }
            set
            {
                problemName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "types" field.</summary>
        public const int Types_FieldNumber = 3;
        private static readonly pb::FieldCodec<TypeDeclaration> _repeated_types_codec
            = pb::FieldCodec.ForMessage(26, TypeDeclaration.Parser);
        private readonly pbc::RepeatedField<TypeDeclaration> types_ = new pbc::RepeatedField<TypeDeclaration>();
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<TypeDeclaration> Types_
        {
            get { return types_; }
        }

        /// <summary>Field number for the "fluents" field.</summary>
        public const int FluentsFieldNumber = 4;
        private static readonly pb::FieldCodec<Fluent> _repeated_fluents_codec
            = pb::FieldCodec.ForMessage(34, Fluent.Parser);
        private readonly pbc::RepeatedField<Fluent> fluents_ = new pbc::RepeatedField<Fluent>();
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Fluent> Fluents
        {
            get { return fluents_; }
        }

        /// <summary>Field number for the "objects" field.</summary>
        public const int ObjectsFieldNumber = 5;
        private static readonly pb::FieldCodec<ObjectDeclaration> _repeated_objects_codec
            = pb::FieldCodec.ForMessage(42, ObjectDeclaration.Parser);
        private readonly pbc::RepeatedField<ObjectDeclaration> objects_ = new pbc::RepeatedField<ObjectDeclaration>();
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<ObjectDeclaration> Objects
        {
            get { return objects_; }
        }

        /// <summary>Field number for the "actions" field.</summary>
        public const int ActionsFieldNumber = 6;
        private static readonly pb::FieldCodec<Action> _repeated_actions_codec
            = pb::FieldCodec.ForMessage(50, Action.Parser);
        private readonly pbc::RepeatedField<Action> actions_ = new pbc::RepeatedField<Action>();
        /// <summary>
        /// List of actions in the domain.
        /// features: ACTION_BASED
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Action> Actions
        {
            get { return actions_; }
        }

        /// <summary>Field number for the "initial_state" field.</summary>
        public const int InitialStateFieldNumber = 7;
        private static readonly pb::FieldCodec<Assignment> _repeated_initialState_codec
            = pb::FieldCodec.ForMessage(58, Assignment.Parser);
        private readonly pbc::RepeatedField<Assignment> initialState_ = new pbc::RepeatedField<Assignment>();
        /// <summary>
        /// Initial state, including default values of state variables.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Assignment> InitialState
        {
            get { return initialState_; }
        }

        /// <summary>Field number for the "timed_effects" field.</summary>
        public const int TimedEffectsFieldNumber = 8;
        private static readonly pb::FieldCodec<TimedEffect> _repeated_timedEffects_codec
            = pb::FieldCodec.ForMessage(66, TimedEffect.Parser);
        private readonly pbc::RepeatedField<TimedEffect> timedEffects_ = new pbc::RepeatedField<TimedEffect>();
        /// <summary>
        /// Facts and effects that are expected to occur strictly later than the initial state.
        /// features: TIMED_EFFECTS
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<TimedEffect> TimedEffects
        {
            get { return timedEffects_; }
        }

        /// <summary>Field number for the "goals" field.</summary>
        public const int GoalsFieldNumber = 9;
        private static readonly pb::FieldCodec<Goal> _repeated_goals_codec
            = pb::FieldCodec.ForMessage(74, Goal.Parser);
        private readonly pbc::RepeatedField<Goal> goals_ = new pbc::RepeatedField<Goal>();
        /// <summary>
        /// Goals of the planning problem.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Goal> Goals
        {
            get { return goals_; }
        }

        /// <summary>Field number for the "features" field.</summary>
        public const int FeaturesFieldNumber = 10;
        private static readonly pb::FieldCodec<Feature> _repeated_features_codec
            = pb::FieldCodec.ForEnum(82, x => (int)x, x => (Feature)x);
        private readonly pbc::RepeatedField<Feature> features_ = new pbc::RepeatedField<Feature>();
        /// <summary>
        /// all features of the problem
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Feature> Features
        {
            get { return features_; }
        }

        /// <summary>Field number for the "metrics" field.</summary>
        public const int MetricsFieldNumber = 11;
        private static readonly pb::FieldCodec<Metric> _repeated_metrics_codec
            = pb::FieldCodec.ForMessage(90, Metric.Parser);
        private readonly pbc::RepeatedField<Metric> metrics_ = new pbc::RepeatedField<Metric>();
        /// <summary>
        /// The plan quality metrics
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Metric> Metrics
        {
            get { return metrics_; }
        }

        /// <summary>Field number for the "hierarchy" field.</summary>
        public const int HierarchyFieldNumber = 12;
        private Hierarchy hierarchy_;
        /// <summary>
        /// If the problem is hierarchical, defines the tasks and methods as well as the initial task network.
        /// features: HIERARCHICAL
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Hierarchy Hierarchy
        {
            get { return hierarchy_; }
            set
            {
                hierarchy_ = value;
            }
        }

        /// <summary>Field number for the "scheduling_extension" field.</summary>
        public const int SchedulingExtensionFieldNumber = 17;
        private SchedulingExtension schedulingExtension_;
        /// <summary>
        /// Scheduling-specific extension of the problem.
        /// features: SCHEDULING
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SchedulingExtension SchedulingExtension
        {
            get { return schedulingExtension_; }
            set
            {
                schedulingExtension_ = value;
            }
        }

        /// <summary>Field number for the "trajectory_constraints" field.</summary>
        public const int TrajectoryConstraintsFieldNumber = 13;
        private static readonly pb::FieldCodec<Expression> _repeated_trajectoryConstraints_codec
            = pb::FieldCodec.ForMessage(106, Expression.Parser);
        private readonly pbc::RepeatedField<Expression> trajectoryConstraints_ = new pbc::RepeatedField<Expression>();
        /// <summary>
        /// Trajectory constraints of the planning problem.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Expression> TrajectoryConstraints
        {
            get { return trajectoryConstraints_; }
        }

        /// <summary>Field number for the "discrete_time" field.</summary>
        public const int DiscreteTimeFieldNumber = 14;
        private bool discreteTime_;
        /// <summary>
        /// Flag defining if the time is discrete
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool DiscreteTime
        {
            get { return discreteTime_; }
            set
            {
                discreteTime_ = value;
            }
        }

        /// <summary>Field number for the "self_overlapping" field.</summary>
        public const int SelfOverlappingFieldNumber = 15;
        private bool selfOverlapping_;
        /// <summary>
        /// Flag defining if the self_overlapping is allowed
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool SelfOverlapping
        {
            get { return selfOverlapping_; }
            set
            {
                selfOverlapping_ = value;
            }
        }

        /// <summary>Field number for the "epsilon" field.</summary>
        public const int EpsilonFieldNumber = 16;
        private Real epsilon_;
        /// <summary>
        /// Optional. epsilon required by the problem
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Real Epsilon
        {
            get { return epsilon_; }
            set
            {
                epsilon_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Problem);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Problem other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (DomainName != other.DomainName) return false;
            if (ProblemName != other.ProblemName) return false;
            if (!types_.Equals(other.types_)) return false;
            if (!fluents_.Equals(other.fluents_)) return false;
            if (!objects_.Equals(other.objects_)) return false;
            if (!actions_.Equals(other.actions_)) return false;
            if (!initialState_.Equals(other.initialState_)) return false;
            if (!timedEffects_.Equals(other.timedEffects_)) return false;
            if (!goals_.Equals(other.goals_)) return false;
            if (!features_.Equals(other.features_)) return false;
            if (!metrics_.Equals(other.metrics_)) return false;
            if (!object.Equals(Hierarchy, other.Hierarchy)) return false;
            if (!object.Equals(SchedulingExtension, other.SchedulingExtension)) return false;
            if (!trajectoryConstraints_.Equals(other.trajectoryConstraints_)) return false;
            if (DiscreteTime != other.DiscreteTime) return false;
            if (SelfOverlapping != other.SelfOverlapping) return false;
            if (!object.Equals(Epsilon, other.Epsilon)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (DomainName.Length != 0) hash ^= DomainName.GetHashCode();
            if (ProblemName.Length != 0) hash ^= ProblemName.GetHashCode();
            hash ^= types_.GetHashCode();
            hash ^= fluents_.GetHashCode();
            hash ^= objects_.GetHashCode();
            hash ^= actions_.GetHashCode();
            hash ^= initialState_.GetHashCode();
            hash ^= timedEffects_.GetHashCode();
            hash ^= goals_.GetHashCode();
            hash ^= features_.GetHashCode();
            hash ^= metrics_.GetHashCode();
            if (hierarchy_ != null) hash ^= Hierarchy.GetHashCode();
            if (schedulingExtension_ != null) hash ^= SchedulingExtension.GetHashCode();
            hash ^= trajectoryConstraints_.GetHashCode();
            if (DiscreteTime != false) hash ^= DiscreteTime.GetHashCode();
            if (SelfOverlapping != false) hash ^= SelfOverlapping.GetHashCode();
            if (epsilon_ != null) hash ^= Epsilon.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (DomainName.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(DomainName);
            }
            if (ProblemName.Length != 0)
            {
                output.WriteRawTag(18);
                output.WriteString(ProblemName);
            }
            types_.WriteTo(output, _repeated_types_codec);
            fluents_.WriteTo(output, _repeated_fluents_codec);
            objects_.WriteTo(output, _repeated_objects_codec);
            actions_.WriteTo(output, _repeated_actions_codec);
            initialState_.WriteTo(output, _repeated_initialState_codec);
            timedEffects_.WriteTo(output, _repeated_timedEffects_codec);
            goals_.WriteTo(output, _repeated_goals_codec);
            features_.WriteTo(output, _repeated_features_codec);
            metrics_.WriteTo(output, _repeated_metrics_codec);
            if (hierarchy_ != null)
            {
                output.WriteRawTag(98);
                output.WriteMessage(Hierarchy);
            }
            trajectoryConstraints_.WriteTo(output, _repeated_trajectoryConstraints_codec);
            if (DiscreteTime != false)
            {
                output.WriteRawTag(112);
                output.WriteBool(DiscreteTime);
            }
            if (SelfOverlapping != false)
            {
                output.WriteRawTag(120);
                output.WriteBool(SelfOverlapping);
            }
            if (epsilon_ != null)
            {
                output.WriteRawTag(130, 1);
                output.WriteMessage(Epsilon);
            }
            if (schedulingExtension_ != null)
            {
                output.WriteRawTag(138, 1);
                output.WriteMessage(SchedulingExtension);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (DomainName.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DomainName);
            }
            if (ProblemName.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ProblemName);
            }
            size += types_.CalculateSize(_repeated_types_codec);
            size += fluents_.CalculateSize(_repeated_fluents_codec);
            size += objects_.CalculateSize(_repeated_objects_codec);
            size += actions_.CalculateSize(_repeated_actions_codec);
            size += initialState_.CalculateSize(_repeated_initialState_codec);
            size += timedEffects_.CalculateSize(_repeated_timedEffects_codec);
            size += goals_.CalculateSize(_repeated_goals_codec);
            size += features_.CalculateSize(_repeated_features_codec);
            size += metrics_.CalculateSize(_repeated_metrics_codec);
            if (hierarchy_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Hierarchy);
            }
            if (schedulingExtension_ != null)
            {
                size += 2 + pb::CodedOutputStream.ComputeMessageSize(SchedulingExtension);
            }
            size += trajectoryConstraints_.CalculateSize(_repeated_trajectoryConstraints_codec);
            if (DiscreteTime != false)
            {
                size += 1 + 1;
            }
            if (SelfOverlapping != false)
            {
                size += 1 + 1;
            }
            if (epsilon_ != null)
            {
                size += 2 + pb::CodedOutputStream.ComputeMessageSize(Epsilon);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Problem other)
        {
            if (other == null)
            {
                return;
            }
            if (other.DomainName.Length != 0)
            {
                DomainName = other.DomainName;
            }
            if (other.ProblemName.Length != 0)
            {
                ProblemName = other.ProblemName;
            }
            types_.Add(other.types_);
            fluents_.Add(other.fluents_);
            objects_.Add(other.objects_);
            actions_.Add(other.actions_);
            initialState_.Add(other.initialState_);
            timedEffects_.Add(other.timedEffects_);
            goals_.Add(other.goals_);
            features_.Add(other.features_);
            metrics_.Add(other.metrics_);
            if (other.hierarchy_ != null)
            {
                if (hierarchy_ == null)
                {
                    hierarchy_ = new Hierarchy();
                }
                Hierarchy.MergeFrom(other.Hierarchy);
            }
            if (other.schedulingExtension_ != null)
            {
                if (schedulingExtension_ == null)
                {
                    schedulingExtension_ = new SchedulingExtension();
                }
                SchedulingExtension.MergeFrom(other.SchedulingExtension);
            }
            trajectoryConstraints_.Add(other.trajectoryConstraints_);
            if (other.DiscreteTime != false)
            {
                DiscreteTime = other.DiscreteTime;
            }
            if (other.SelfOverlapping != false)
            {
                SelfOverlapping = other.SelfOverlapping;
            }
            if (other.epsilon_ != null)
            {
                if (epsilon_ == null)
                {
                    epsilon_ = new Real();
                }
                Epsilon.MergeFrom(other.Epsilon);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            DomainName = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            ProblemName = input.ReadString();
                            break;
                        }
                    case 26:
                        {
                            types_.AddEntriesFrom(input, _repeated_types_codec);
                            break;
                        }
                    case 34:
                        {
                            fluents_.AddEntriesFrom(input, _repeated_fluents_codec);
                            break;
                        }
                    case 42:
                        {
                            objects_.AddEntriesFrom(input, _repeated_objects_codec);
                            break;
                        }
                    case 50:
                        {
                            actions_.AddEntriesFrom(input, _repeated_actions_codec);
                            break;
                        }
                    case 58:
                        {
                            initialState_.AddEntriesFrom(input, _repeated_initialState_codec);
                            break;
                        }
                    case 66:
                        {
                            timedEffects_.AddEntriesFrom(input, _repeated_timedEffects_codec);
                            break;
                        }
                    case 74:
                        {
                            goals_.AddEntriesFrom(input, _repeated_goals_codec);
                            break;
                        }
                    case 82:
                    case 80:
                        {
                            features_.AddEntriesFrom(input, _repeated_features_codec);
                            break;
                        }
                    case 90:
                        {
                            metrics_.AddEntriesFrom(input, _repeated_metrics_codec);
                            break;
                        }
                    case 98:
                        {
                            if (hierarchy_ == null)
                            {
                                hierarchy_ = new Hierarchy();
                            }
                            input.ReadMessage(hierarchy_);
                            break;
                        }
                    case 106:
                        {
                            trajectoryConstraints_.AddEntriesFrom(input, _repeated_trajectoryConstraints_codec);
                            break;
                        }
                    case 112:
                        {
                            DiscreteTime = input.ReadBool();
                            break;
                        }
                    case 120:
                        {
                            SelfOverlapping = input.ReadBool();
                            break;
                        }
                    case 130:
                        {
                            if (epsilon_ == null)
                            {
                                epsilon_ = new Real();
                            }
                            input.ReadMessage(epsilon_);
                            break;
                        }
                    case 138:
                        {
                            if (schedulingExtension_ == null)
                            {
                                schedulingExtension_ = new SchedulingExtension();
                            }
                            input.ReadMessage(schedulingExtension_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Representation of an action instance that appears in a plan.
    /// </summary>
    public sealed partial class ActionInstance : pb::IMessage<ActionInstance>
    {
        private static readonly pb::MessageParser<ActionInstance> _parser = new pb::MessageParser<ActionInstance>(() => new ActionInstance());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ActionInstance> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[31]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ActionInstance()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ActionInstance(ActionInstance other) : this()
        {
            id_ = other.id_;
            actionName_ = other.actionName_;
            parameters_ = other.parameters_.Clone();
            startTime_ = other.startTime_ != null ? other.startTime_.Clone() : null;
            endTime_ = other.endTime_ != null ? other.endTime_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ActionInstance Clone()
        {
            return new ActionInstance(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private string id_ = "";
        /// <summary>
        /// Optional. A unique identifier of the action that might be used to refer to it (e.g. in HTN plans).
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Id
        {
            get { return id_; }
            set
            {
                id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "action_name" field.</summary>
        public const int ActionNameFieldNumber = 2;
        private string actionName_ = "";
        /// <summary>
        /// name of the action
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ActionName
        {
            get { return actionName_; }
            set
            {
                actionName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "parameters" field.</summary>
        public const int ParametersFieldNumber = 3;
        private static readonly pb::FieldCodec<Atom> _repeated_parameters_codec
            = pb::FieldCodec.ForMessage(26, Atom.Parser);
        private readonly pbc::RepeatedField<Atom> parameters_ = new pbc::RepeatedField<Atom>();
        /// <summary>
        /// Parameters of the action instance, required to be constants.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Atom> Parameters
        {
            get { return parameters_; }
        }

        /// <summary>Field number for the "start_time" field.</summary>
        public const int StartTimeFieldNumber = 4;
        private Real startTime_;
        /// <summary>
        /// Start time of the action. The default 0 value is OK in the case of non-temporal planning
        /// feature: [DURATIVE_ACTIONS]
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Real StartTime
        {
            get { return startTime_; }
            set
            {
                startTime_ = value;
            }
        }

        /// <summary>Field number for the "end_time" field.</summary>
        public const int EndTimeFieldNumber = 5;
        private Real endTime_;
        /// <summary>
        /// End time of the action. The default 0 value is OK in the case of non-temporal planning
        /// feature: [DURATIVE_ACTIONS]
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Real EndTime
        {
            get { return endTime_; }
            set
            {
                endTime_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as ActionInstance);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ActionInstance other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Id != other.Id) return false;
            if (ActionName != other.ActionName) return false;
            if (!parameters_.Equals(other.parameters_)) return false;
            if (!object.Equals(StartTime, other.StartTime)) return false;
            if (!object.Equals(EndTime, other.EndTime)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Id.Length != 0) hash ^= Id.GetHashCode();
            if (ActionName.Length != 0) hash ^= ActionName.GetHashCode();
            hash ^= parameters_.GetHashCode();
            if (startTime_ != null) hash ^= StartTime.GetHashCode();
            if (endTime_ != null) hash ^= EndTime.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Id.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Id);
            }
            if (ActionName.Length != 0)
            {
                output.WriteRawTag(18);
                output.WriteString(ActionName);
            }
            parameters_.WriteTo(output, _repeated_parameters_codec);
            if (startTime_ != null)
            {
                output.WriteRawTag(34);
                output.WriteMessage(StartTime);
            }
            if (endTime_ != null)
            {
                output.WriteRawTag(42);
                output.WriteMessage(EndTime);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Id.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
            }
            if (ActionName.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ActionName);
            }
            size += parameters_.CalculateSize(_repeated_parameters_codec);
            if (startTime_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
            }
            if (endTime_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ActionInstance other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Id.Length != 0)
            {
                Id = other.Id;
            }
            if (other.ActionName.Length != 0)
            {
                ActionName = other.ActionName;
            }
            parameters_.Add(other.parameters_);
            if (other.startTime_ != null)
            {
                if (startTime_ == null)
                {
                    startTime_ = new Real();
                }
                StartTime.MergeFrom(other.StartTime);
            }
            if (other.endTime_ != null)
            {
                if (endTime_ == null)
                {
                    endTime_ = new Real();
                }
                EndTime.MergeFrom(other.EndTime);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Id = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            ActionName = input.ReadString();
                            break;
                        }
                    case 26:
                        {
                            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
                            break;
                        }
                    case 34:
                        {
                            if (startTime_ == null)
                            {
                                startTime_ = new Real();
                            }
                            input.ReadMessage(startTime_);
                            break;
                        }
                    case 42:
                        {
                            if (endTime_ == null)
                            {
                                endTime_ = new Real();
                            }
                            input.ReadMessage(endTime_);
                            break;
                        }
                }
            }
        }

    }

    public sealed partial class MethodInstance : pb::IMessage<MethodInstance>
    {
        private static readonly pb::MessageParser<MethodInstance> _parser = new pb::MessageParser<MethodInstance>(() => new MethodInstance());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MethodInstance> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[32]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MethodInstance()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MethodInstance(MethodInstance other) : this()
        {
            id_ = other.id_;
            methodName_ = other.methodName_;
            parameters_ = other.parameters_.Clone();
            subtasks_ = other.subtasks_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MethodInstance Clone()
        {
            return new MethodInstance(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private string id_ = "";
        /// <summary>
        ///  A unique identifier of the method that is used to refer to it in the hierarchy.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Id
        {
            get { return id_; }
            set
            {
                id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "method_name" field.</summary>
        public const int MethodNameFieldNumber = 2;
        private string methodName_ = "";
        /// <summary>
        /// name of the method
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string MethodName
        {
            get { return methodName_; }
            set
            {
                methodName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        /// <summary>Field number for the "parameters" field.</summary>
        public const int ParametersFieldNumber = 3;
        private static readonly pb::FieldCodec<Atom> _repeated_parameters_codec
            = pb::FieldCodec.ForMessage(26, Atom.Parser);
        private readonly pbc::RepeatedField<Atom> parameters_ = new pbc::RepeatedField<Atom>();
        /// <summary>
        /// Parameters of the method instance, required to be constants.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<Atom> Parameters
        {
            get { return parameters_; }
        }

        /// <summary>Field number for the "subtasks" field.</summary>
        public const int SubtasksFieldNumber = 6;
        private static readonly pbc::MapField<string, string>.Codec _map_subtasks_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 50);
        private readonly pbc::MapField<string, string> subtasks_ = new pbc::MapField<string, string>();
        /// <summary>
        /// A mapping of the IDs of the method's subtasks into the IDs of the action/methods that refine them.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, string> Subtasks
        {
            get { return subtasks_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as MethodInstance);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MethodInstance other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Id != other.Id) return false;
            if (MethodName != other.MethodName) return false;
            if (!parameters_.Equals(other.parameters_)) return false;
            if (!Subtasks.Equals(other.Subtasks)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Id.Length != 0) hash ^= Id.GetHashCode();
            if (MethodName.Length != 0) hash ^= MethodName.GetHashCode();
            hash ^= parameters_.GetHashCode();
            hash ^= Subtasks.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Id.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Id);
            }
            if (MethodName.Length != 0)
            {
                output.WriteRawTag(18);
                output.WriteString(MethodName);
            }
            parameters_.WriteTo(output, _repeated_parameters_codec);
            subtasks_.WriteTo(output, _map_subtasks_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Id.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
            }
            if (MethodName.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(MethodName);
            }
            size += parameters_.CalculateSize(_repeated_parameters_codec);
            size += subtasks_.CalculateSize(_map_subtasks_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MethodInstance other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Id.Length != 0)
            {
                Id = other.Id;
            }
            if (other.MethodName.Length != 0)
            {
                MethodName = other.MethodName;
            }
            parameters_.Add(other.parameters_);
            subtasks_.Add(other.subtasks_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Id = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            MethodName = input.ReadString();
                            break;
                        }
                    case 26:
                        {
                            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
                            break;
                        }
                    case 50:
                        {
                            subtasks_.AddEntriesFrom(input, _map_subtasks_codec);
                            break;
                        }
                }
            }
        }

    }

    public sealed partial class PlanHierarchy : pb::IMessage<PlanHierarchy>
    {
        private static readonly pb::MessageParser<PlanHierarchy> _parser = new pb::MessageParser<PlanHierarchy>(() => new PlanHierarchy());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PlanHierarchy> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[33]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanHierarchy()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanHierarchy(PlanHierarchy other) : this()
        {
            rootTasks_ = other.rootTasks_.Clone();
            methods_ = other.methods_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanHierarchy Clone()
        {
            return new PlanHierarchy(this);
        }

        /// <summary>Field number for the "root_tasks" field.</summary>
        public const int RootTasksFieldNumber = 1;
        private static readonly pbc::MapField<string, string>.Codec _map_rootTasks_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 10);
        private readonly pbc::MapField<string, string> rootTasks_ = new pbc::MapField<string, string>();
        /// <summary>
        /// A mapping of the root task IDs into the IDs of the actions and methods that refine them.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, string> RootTasks
        {
            get { return rootTasks_; }
        }

        /// <summary>Field number for the "methods" field.</summary>
        public const int MethodsFieldNumber = 2;
        private static readonly pb::FieldCodec<MethodInstance> _repeated_methods_codec
            = pb::FieldCodec.ForMessage(18, MethodInstance.Parser);
        private readonly pbc::RepeatedField<MethodInstance> methods_ = new pbc::RepeatedField<MethodInstance>();
        /// <summary>
        /// Instances of all methods used in the plan.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<MethodInstance> Methods
        {
            get { return methods_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as PlanHierarchy);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PlanHierarchy other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!RootTasks.Equals(other.RootTasks)) return false;
            if (!methods_.Equals(other.methods_)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= RootTasks.GetHashCode();
            hash ^= methods_.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            rootTasks_.WriteTo(output, _map_rootTasks_codec);
            methods_.WriteTo(output, _repeated_methods_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += rootTasks_.CalculateSize(_map_rootTasks_codec);
            size += methods_.CalculateSize(_repeated_methods_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PlanHierarchy other)
        {
            if (other == null)
            {
                return;
            }
            rootTasks_.Add(other.rootTasks_);
            methods_.Add(other.methods_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            rootTasks_.AddEntriesFrom(input, _map_rootTasks_codec);
                            break;
                        }
                    case 18:
                        {
                            methods_.AddEntriesFrom(input, _repeated_methods_codec);
                            break;
                        }
                }
            }
        }

    }

    public sealed partial class Plan : pb::IMessage<Plan>
    {
        private static readonly pb::MessageParser<Plan> _parser = new pb::MessageParser<Plan>(() => new Plan());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Plan> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[34]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Plan()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Plan(Plan other) : this()
        {
            actions_ = other.actions_.Clone();
            hierarchy_ = other.hierarchy_ != null ? other.hierarchy_.Clone() : null;
            schedule_ = other.schedule_ != null ? other.schedule_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Plan Clone()
        {
            return new Plan(this);
        }

        /// <summary>Field number for the "actions" field.</summary>
        public const int ActionsFieldNumber = 1;
        private static readonly pb::FieldCodec<ActionInstance> _repeated_actions_codec
            = pb::FieldCodec.ForMessage(10, ActionInstance.Parser);
        private readonly pbc::RepeatedField<ActionInstance> actions_ = new pbc::RepeatedField<ActionInstance>();
        /// <summary>
        /// An ordered sequence of actions that appear in the plan.
        /// The order of the actions in the list must be compatible with the partial order of the start times.
        /// In case of non-temporal planning, this allows having all start time at 0 and only rely on the order in this sequence.
        /// features: ACTION_BASED
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<ActionInstance> Actions
        {
            get { return actions_; }
        }

        /// <summary>Field number for the "hierarchy" field.</summary>
        public const int HierarchyFieldNumber = 2;
        private PlanHierarchy hierarchy_;
        /// <summary>
        /// When the plan is hierarchical, this object provides the decomposition of hte root tasks into the actions of the plan
        /// feature: HIERARCHY
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanHierarchy Hierarchy
        {
            get { return hierarchy_; }
            set
            {
                hierarchy_ = value;
            }
        }

        /// <summary>Field number for the "schedule" field.</summary>
        public const int ScheduleFieldNumber = 3;
        private Schedule schedule_;
        /// <summary>
        /// Solution representation of a scheduling problem.
        /// feature: SCHEDULING
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Schedule Schedule
        {
            get { return schedule_; }
            set
            {
                schedule_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Plan);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Plan other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!actions_.Equals(other.actions_)) return false;
            if (!object.Equals(Hierarchy, other.Hierarchy)) return false;
            if (!object.Equals(Schedule, other.Schedule)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= actions_.GetHashCode();
            if (hierarchy_ != null) hash ^= Hierarchy.GetHashCode();
            if (schedule_ != null) hash ^= Schedule.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            actions_.WriteTo(output, _repeated_actions_codec);
            if (hierarchy_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Hierarchy);
            }
            if (schedule_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(Schedule);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            size += actions_.CalculateSize(_repeated_actions_codec);
            if (hierarchy_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Hierarchy);
            }
            if (schedule_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Schedule);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Plan other)
        {
            if (other == null)
            {
                return;
            }
            actions_.Add(other.actions_);
            if (other.hierarchy_ != null)
            {
                if (hierarchy_ == null)
                {
                    hierarchy_ = new PlanHierarchy();
                }
                Hierarchy.MergeFrom(other.Hierarchy);
            }
            if (other.schedule_ != null)
            {
                if (schedule_ == null)
                {
                    schedule_ = new Schedule();
                }
                Schedule.MergeFrom(other.Schedule);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            actions_.AddEntriesFrom(input, _repeated_actions_codec);
                            break;
                        }
                    case 18:
                        {
                            if (hierarchy_ == null)
                            {
                                hierarchy_ = new PlanHierarchy();
                            }
                            input.ReadMessage(hierarchy_);
                            break;
                        }
                    case 26:
                        {
                            if (schedule_ == null)
                            {
                                schedule_ = new Schedule();
                            }
                            input.ReadMessage(schedule_);
                            break;
                        }
                }
            }
        }

    }

    public sealed partial class PlanRequest : pb::IMessage<PlanRequest>
    {
        private static readonly pb::MessageParser<PlanRequest> _parser = new pb::MessageParser<PlanRequest>(() => new PlanRequest());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PlanRequest> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[35]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanRequest()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanRequest(PlanRequest other) : this()
        {
            problem_ = other.problem_ != null ? other.problem_.Clone() : null;
            resolutionMode_ = other.resolutionMode_;
            timeout_ = other.timeout_;
            engineOptions_ = other.engineOptions_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanRequest Clone()
        {
            return new PlanRequest(this);
        }

        /// <summary>Field number for the "problem" field.</summary>
        public const int ProblemFieldNumber = 1;
        private Problem problem_;
        /// <summary>
        /// Problem that should be solved.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Problem Problem
        {
            get { return problem_; }
            set
            {
                problem_ = value;
            }
        }

        /// <summary>Field number for the "resolution_mode" field.</summary>
        public const int ResolutionModeFieldNumber = 2;
        private PlanRequest.Types.Mode resolutionMode_ = 0;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanRequest.Types.Mode ResolutionMode
        {
            get { return resolutionMode_; }
            set
            {
                resolutionMode_ = value;
            }
        }

        /// <summary>Field number for the "timeout" field.</summary>
        public const int TimeoutFieldNumber = 3;
        private double timeout_;
        /// <summary>
        /// Max allowed runtime time in seconds.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Timeout
        {
            get { return timeout_; }
            set
            {
                timeout_ = value;
            }
        }

        /// <summary>Field number for the "engine_options" field.</summary>
        public const int EngineOptionsFieldNumber = 4;
        private static readonly pbc::MapField<string, string>.Codec _map_engineOptions_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 34);
        private readonly pbc::MapField<string, string> engineOptions_ = new pbc::MapField<string, string>();
        /// <summary>
        /// Engine specific options to be passed to the engine
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, string> EngineOptions
        {
            get { return engineOptions_; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as PlanRequest);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PlanRequest other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Problem, other.Problem)) return false;
            if (ResolutionMode != other.ResolutionMode) return false;
            if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Timeout, other.Timeout)) return false;
            if (!EngineOptions.Equals(other.EngineOptions)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (problem_ != null) hash ^= Problem.GetHashCode();
            if (ResolutionMode != 0) hash ^= ResolutionMode.GetHashCode();
            if (Timeout != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Timeout);
            hash ^= EngineOptions.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (problem_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Problem);
            }
            if (ResolutionMode != 0)
            {
                output.WriteRawTag(16);
                output.WriteEnum((int)ResolutionMode);
            }
            if (Timeout != 0D)
            {
                output.WriteRawTag(25);
                output.WriteDouble(Timeout);
            }
            engineOptions_.WriteTo(output, _map_engineOptions_codec);
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (problem_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Problem);
            }
            if (ResolutionMode != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)ResolutionMode);
            }
            if (Timeout != 0D)
            {
                size += 1 + 8;
            }
            size += engineOptions_.CalculateSize(_map_engineOptions_codec);
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PlanRequest other)
        {
            if (other == null)
            {
                return;
            }
            if (other.problem_ != null)
            {
                if (problem_ == null)
                {
                    problem_ = new Problem();
                }
                Problem.MergeFrom(other.Problem);
            }
            if (other.ResolutionMode != 0)
            {
                ResolutionMode = other.ResolutionMode;
            }
            if (other.Timeout != 0D)
            {
                Timeout = other.Timeout;
            }
            engineOptions_.Add(other.engineOptions_);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (problem_ == null)
                            {
                                problem_ = new Problem();
                            }
                            input.ReadMessage(problem_);
                            break;
                        }
                    case 16:
                        {
                            resolutionMode_ = (PlanRequest.Types.Mode)input.ReadEnum();
                            break;
                        }
                    case 25:
                        {
                            Timeout = input.ReadDouble();
                            break;
                        }
                    case 34:
                        {
                            engineOptions_.AddEntriesFrom(input, _map_engineOptions_codec);
                            break;
                        }
                }
            }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the PlanRequest message type.</summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types
        {
            public enum Mode
            {
                [pbr::OriginalName("SATISFIABLE")] Satisfiable = 0,
                [pbr::OriginalName("SOLVED_OPTIMALLY")] SolvedOptimally = 1,
            }

        }
        #endregion

    }

    public sealed partial class ValidationRequest : pb::IMessage<ValidationRequest>
    {
        private static readonly pb::MessageParser<ValidationRequest> _parser = new pb::MessageParser<ValidationRequest>(() => new ValidationRequest());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ValidationRequest> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[36]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ValidationRequest()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ValidationRequest(ValidationRequest other) : this()
        {
            problem_ = other.problem_ != null ? other.problem_.Clone() : null;
            plan_ = other.plan_ != null ? other.plan_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ValidationRequest Clone()
        {
            return new ValidationRequest(this);
        }

        /// <summary>Field number for the "problem" field.</summary>
        public const int ProblemFieldNumber = 1;
        private Problem problem_;
        /// <summary>
        /// Problem to be validated.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Problem Problem
        {
            get { return problem_; }
            set
            {
                problem_ = value;
            }
        }

        /// <summary>Field number for the "plan" field.</summary>
        public const int PlanFieldNumber = 2;
        private Plan plan_;
        /// <summary>
        /// Plan to validate.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Plan Plan
        {
            get { return plan_; }
            set
            {
                plan_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as ValidationRequest);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ValidationRequest other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Problem, other.Problem)) return false;
            if (!object.Equals(Plan, other.Plan)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (problem_ != null) hash ^= Problem.GetHashCode();
            if (plan_ != null) hash ^= Plan.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (problem_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Problem);
            }
            if (plan_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Plan);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (problem_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Problem);
            }
            if (plan_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Plan);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ValidationRequest other)
        {
            if (other == null)
            {
                return;
            }
            if (other.problem_ != null)
            {
                if (problem_ == null)
                {
                    problem_ = new Problem();
                }
                Problem.MergeFrom(other.Problem);
            }
            if (other.plan_ != null)
            {
                if (plan_ == null)
                {
                    plan_ = new Plan();
                }
                Plan.MergeFrom(other.Plan);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (problem_ == null)
                            {
                                problem_ = new Problem();
                            }
                            input.ReadMessage(problem_);
                            break;
                        }
                    case 18:
                        {
                            if (plan_ == null)
                            {
                                plan_ = new Plan();
                            }
                            input.ReadMessage(plan_);
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// A freely formatted logging message.
    /// Each message is annotated with its criticality level from the minimal (DEBUG) to the maximal (ERROR).
    /// Criticality level is expected to be used by an end user to decide the level of verbosity.
    /// </summary>
    public sealed partial class LogMessage : pb::IMessage<LogMessage>
    {
        private static readonly pb::MessageParser<LogMessage> _parser = new pb::MessageParser<LogMessage>(() => new LogMessage());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<LogMessage> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[37]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LogMessage()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LogMessage(LogMessage other) : this()
        {
            level_ = other.level_;
            message_ = other.message_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LogMessage Clone()
        {
            return new LogMessage(this);
        }

        /// <summary>Field number for the "level" field.</summary>
        public const int LevelFieldNumber = 1;
        private LogMessage.Types.LogLevel level_ = 0;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LogMessage.Types.LogLevel Level
        {
            get { return level_; }
            set
            {
                level_ = value;
            }
        }

        /// <summary>Field number for the "message" field.</summary>
        public const int MessageFieldNumber = 2;
        private string message_ = "";
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Message
        {
            get { return message_; }
            set
            {
                message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as LogMessage);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(LogMessage other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Level != other.Level) return false;
            if (Message != other.Message) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Level != 0) hash ^= Level.GetHashCode();
            if (Message.Length != 0) hash ^= Message.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Level != 0)
            {
                output.WriteRawTag(8);
                output.WriteEnum((int)Level);
            }
            if (Message.Length != 0)
            {
                output.WriteRawTag(18);
                output.WriteString(Message);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Level != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Level);
            }
            if (Message.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(LogMessage other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Level != 0)
            {
                Level = other.Level;
            }
            if (other.Message.Length != 0)
            {
                Message = other.Message;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 8:
                        {
                            level_ = (LogMessage.Types.LogLevel)input.ReadEnum();
                            break;
                        }
                    case 18:
                        {
                            Message = input.ReadString();
                            break;
                        }
                }
            }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the LogMessage message type.</summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types
        {
            public enum LogLevel
            {
                [pbr::OriginalName("DEBUG")] Debug = 0,
                [pbr::OriginalName("INFO")] Info = 1,
                [pbr::OriginalName("WARNING")] Warning = 2,
                [pbr::OriginalName("ERROR")] Error = 3,
            }

        }
        #endregion

    }

    /// <summary>
    /// Message sent by engine.
    /// Contains the engine exit status as well as the best plan found if any.
    /// </summary>
    public sealed partial class PlanGenerationResult : pb::IMessage<PlanGenerationResult>
    {
        private static readonly pb::MessageParser<PlanGenerationResult> _parser = new pb::MessageParser<PlanGenerationResult>(() => new PlanGenerationResult());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PlanGenerationResult> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[38]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanGenerationResult()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanGenerationResult(PlanGenerationResult other) : this()
        {
            status_ = other.status_;
            plan_ = other.plan_ != null ? other.plan_.Clone() : null;
            metrics_ = other.metrics_.Clone();
            logMessages_ = other.logMessages_.Clone();
            engine_ = other.engine_ != null ? other.engine_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanGenerationResult Clone()
        {
            return new PlanGenerationResult(this);
        }

        /// <summary>Field number for the "status" field.</summary>
        public const int StatusFieldNumber = 1;
        private PlanGenerationResult.Types.Status status_ = 0;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PlanGenerationResult.Types.Status Status
        {
            get { return status_; }
            set
            {
                status_ = value;
            }
        }

        /// <summary>Field number for the "plan" field.</summary>
        public const int PlanFieldNumber = 2;
        private Plan plan_;
        /// <summary>
        /// Optional. Best plan found if any.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Plan Plan
        {
            get { return plan_; }
            set
            {
                plan_ = value;
            }
        }

        /// <summary>Field number for the "metrics" field.</summary>
        public const int MetricsFieldNumber = 3;
        private static readonly pbc::MapField<string, string>.Codec _map_metrics_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 26);
        private readonly pbc::MapField<string, string> metrics_ = new pbc::MapField<string, string>();
        /// <summary>
        /// A set of engine specific values that can be reported, for instance
        /// - "grounding-time": "10ms"
        /// - "expanded-states": "1290"
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, string> Metrics
        {
            get { return metrics_; }
        }

        /// <summary>Field number for the "log_messages" field.</summary>
        public const int LogMessagesFieldNumber = 4;
        private static readonly pb::FieldCodec<LogMessage> _repeated_logMessages_codec
            = pb::FieldCodec.ForMessage(34, LogMessage.Parser);
        private readonly pbc::RepeatedField<LogMessage> logMessages_ = new pbc::RepeatedField<LogMessage>();
        /// <summary>
        /// Optional log messages about the engine's activity.
        /// Note that it should not be expected that logging messages are visible to the end user.
        /// If used in conjunction with INTERNAL_ERROR or UNSUPPORTED_PROBLEM, it would be expected to have at least one log message at the ERROR level.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<LogMessage> LogMessages
        {
            get { return logMessages_; }
        }

        /// <summary>Field number for the "engine" field.</summary>
        public const int EngineFieldNumber = 5;
        private Engine engine_;
        /// <summary>
        /// Synthetic description of the engine that generated this message.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Engine Engine
        {
            get { return engine_; }
            set
            {
                engine_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as PlanGenerationResult);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PlanGenerationResult other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Status != other.Status) return false;
            if (!object.Equals(Plan, other.Plan)) return false;
            if (!Metrics.Equals(other.Metrics)) return false;
            if (!logMessages_.Equals(other.logMessages_)) return false;
            if (!object.Equals(Engine, other.Engine)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Status != 0) hash ^= Status.GetHashCode();
            if (plan_ != null) hash ^= Plan.GetHashCode();
            hash ^= Metrics.GetHashCode();
            hash ^= logMessages_.GetHashCode();
            if (engine_ != null) hash ^= Engine.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Status != 0)
            {
                output.WriteRawTag(8);
                output.WriteEnum((int)Status);
            }
            if (plan_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Plan);
            }
            metrics_.WriteTo(output, _map_metrics_codec);
            logMessages_.WriteTo(output, _repeated_logMessages_codec);
            if (engine_ != null)
            {
                output.WriteRawTag(42);
                output.WriteMessage(Engine);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Status != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Status);
            }
            if (plan_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Plan);
            }
            size += metrics_.CalculateSize(_map_metrics_codec);
            size += logMessages_.CalculateSize(_repeated_logMessages_codec);
            if (engine_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Engine);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PlanGenerationResult other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Status != 0)
            {
                Status = other.Status;
            }
            if (other.plan_ != null)
            {
                if (plan_ == null)
                {
                    plan_ = new Plan();
                }
                Plan.MergeFrom(other.Plan);
            }
            metrics_.Add(other.metrics_);
            logMessages_.Add(other.logMessages_);
            if (other.engine_ != null)
            {
                if (engine_ == null)
                {
                    engine_ = new Engine();
                }
                Engine.MergeFrom(other.Engine);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 8:
                        {
                            status_ = (PlanGenerationResult.Types.Status)input.ReadEnum();
                            break;
                        }
                    case 18:
                        {
                            if (plan_ == null)
                            {
                                plan_ = new Plan();
                            }
                            input.ReadMessage(plan_);
                            break;
                        }
                    case 26:
                        {
                            metrics_.AddEntriesFrom(input, _map_metrics_codec);
                            break;
                        }
                    case 34:
                        {
                            logMessages_.AddEntriesFrom(input, _repeated_logMessages_codec);
                            break;
                        }
                    case 42:
                        {
                            if (engine_ == null)
                            {
                                engine_ = new Engine();
                            }
                            input.ReadMessage(engine_);
                            break;
                        }
                }
            }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the PlanGenerationResult message type.</summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types
        {
            /// <summary>
            /// ==== Engine stopped normally ======
            /// </summary>
            public enum Status
            {
                /// <summary>
                /// Valid plan found
                /// The `plan` field must be set.
                /// </summary>
                [pbr::OriginalName("SOLVED_SATISFICING")] SolvedSatisficing = 0,
                /// <summary>
                /// Plan found with optimality guarantee
                /// The `plan` field must be set and contains an optimal solution.
                /// </summary>
                [pbr::OriginalName("SOLVED_OPTIMALLY")] SolvedOptimally = 1,
                /// <summary>
                /// No plan exists
                /// </summary>
                [pbr::OriginalName("UNSOLVABLE_PROVEN")] UnsolvableProven = 2,
                /// <summary>
                /// The engine was not able to find a solution but does not give any guarantee that none exist
                /// (i.e. the engine might not be complete)
                /// </summary>
                [pbr::OriginalName("UNSOLVABLE_INCOMPLETELY")] UnsolvableIncompletely = 3,
                /// <summary>
                /// The engine ran out of time
                /// </summary>
                [pbr::OriginalName("TIMEOUT")] Timeout = 13,
                /// <summary>
                /// The engine ran out of memory
                /// </summary>
                [pbr::OriginalName("MEMOUT")] Memout = 14,
                /// <summary>
                /// The engine faced an internal error.
                /// </summary>
                [pbr::OriginalName("INTERNAL_ERROR")] InternalError = 15,
                /// <summary>
                /// The problem submitted is not supported by the engine.
                /// </summary>
                [pbr::OriginalName("UNSUPPORTED_PROBLEM")] UnsupportedProblem = 16,
                /// <summary>
                /// ====== Intermediate answer ======
                /// This Answer is an Intermediate Answer and not a Final one
                /// </summary>
                [pbr::OriginalName("INTERMEDIATE")] Intermediate = 17,
            }

        }
        #endregion

    }

    public sealed partial class Engine : pb::IMessage<Engine>
    {
        private static readonly pb::MessageParser<Engine> _parser = new pb::MessageParser<Engine>(() => new Engine());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Engine> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[39]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Engine()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Engine(Engine other) : this()
        {
            name_ = other.name_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Engine Clone()
        {
            return new Engine(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Short name of the engine (planner, validator, ...)
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name
        {
            get { return name_; }
            set
            {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as Engine);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Engine other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Name != other.Name) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Name.Length != 0) hash ^= Name.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Name.Length != 0)
            {
                output.WriteRawTag(10);
                output.WriteString(Name);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Name.Length != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Engine other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Name.Length != 0)
            {
                Name = other.Name;
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            Name = input.ReadString();
                            break;
                        }
                }
            }
        }

    }

    /// <summary>
    /// Message sent by the validator.
    /// </summary>
    public sealed partial class ValidationResult : pb::IMessage<ValidationResult>
    {
        private static readonly pb::MessageParser<ValidationResult> _parser = new pb::MessageParser<ValidationResult>(() => new ValidationResult());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ValidationResult> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[40]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ValidationResult()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ValidationResult(ValidationResult other) : this()
        {
            status_ = other.status_;
            logMessages_ = other.logMessages_.Clone();
            engine_ = other.engine_ != null ? other.engine_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ValidationResult Clone()
        {
            return new ValidationResult(this);
        }

        /// <summary>Field number for the "status" field.</summary>
        public const int StatusFieldNumber = 1;
        private ValidationResult.Types.ValidationResultStatus status_ = 0;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ValidationResult.Types.ValidationResultStatus Status
        {
            get { return status_; }
            set
            {
                status_ = value;
            }
        }

        /// <summary>Field number for the "log_messages" field.</summary>
        public const int LogMessagesFieldNumber = 2;
        private static readonly pb::FieldCodec<LogMessage> _repeated_logMessages_codec
            = pb::FieldCodec.ForMessage(18, LogMessage.Parser);
        private readonly pbc::RepeatedField<LogMessage> logMessages_ = new pbc::RepeatedField<LogMessage>();
        /// <summary>
        /// Optional. Information given by the engine to the user.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<LogMessage> LogMessages
        {
            get { return logMessages_; }
        }

        /// <summary>Field number for the "engine" field.</summary>
        public const int EngineFieldNumber = 3;
        private Engine engine_;
        /// <summary>
        /// Synthetic description of the engine that generated this message.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Engine Engine
        {
            get { return engine_; }
            set
            {
                engine_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as ValidationResult);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ValidationResult other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Status != other.Status) return false;
            if (!logMessages_.Equals(other.logMessages_)) return false;
            if (!object.Equals(Engine, other.Engine)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (Status != 0) hash ^= Status.GetHashCode();
            hash ^= logMessages_.GetHashCode();
            if (engine_ != null) hash ^= Engine.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (Status != 0)
            {
                output.WriteRawTag(8);
                output.WriteEnum((int)Status);
            }
            logMessages_.WriteTo(output, _repeated_logMessages_codec);
            if (engine_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(Engine);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (Status != 0)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Status);
            }
            size += logMessages_.CalculateSize(_repeated_logMessages_codec);
            if (engine_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Engine);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ValidationResult other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Status != 0)
            {
                Status = other.Status;
            }
            logMessages_.Add(other.logMessages_);
            if (other.engine_ != null)
            {
                if (engine_ == null)
                {
                    engine_ = new Engine();
                }
                Engine.MergeFrom(other.Engine);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 8:
                        {
                            status_ = (ValidationResult.Types.ValidationResultStatus)input.ReadEnum();
                            break;
                        }
                    case 18:
                        {
                            logMessages_.AddEntriesFrom(input, _repeated_logMessages_codec);
                            break;
                        }
                    case 26:
                        {
                            if (engine_ == null)
                            {
                                engine_ = new Engine();
                            }
                            input.ReadMessage(engine_);
                            break;
                        }
                }
            }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the ValidationResult message type.</summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types
        {
            public enum ValidationResultStatus
            {
                /// <summary>
                /// The Plan is valid for the Problem.
                /// </summary>
                [pbr::OriginalName("VALID")] Valid = 0,
                /// <summary>
                /// The Plan is not valid for the Problem.
                /// </summary>
                [pbr::OriginalName("INVALID")] Invalid = 1,
                /// <summary>
                /// The engine can't determine if the plan is VALID or INVALID for the Problem.
                /// </summary>
                [pbr::OriginalName("UNKNOWN")] Unknown = 2,
            }

        }
        #endregion

    }

    /// <summary>
    /// Message sent by the grounder.
    /// </summary>
    public sealed partial class CompilerResult : pb::IMessage<CompilerResult>
    {
        private static readonly pb::MessageParser<CompilerResult> _parser = new pb::MessageParser<CompilerResult>(() => new CompilerResult());
        private pb::UnknownFieldSet _unknownFields;
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CompilerResult> Parser { get { return _parser; } }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return UnifiedPlanningReflection.Descriptor.MessageTypes[41]; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CompilerResult()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CompilerResult(CompilerResult other) : this()
        {
            problem_ = other.problem_ != null ? other.problem_.Clone() : null;
            mapBackPlan_ = other.mapBackPlan_.Clone();
            logMessages_ = other.logMessages_.Clone();
            engine_ = other.engine_ != null ? other.engine_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CompilerResult Clone()
        {
            return new CompilerResult(this);
        }

        /// <summary>Field number for the "problem" field.</summary>
        public const int ProblemFieldNumber = 1;
        private Problem problem_;
        /// <summary>
        /// The problem generated by the Compiler
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Problem Problem
        {
            get { return problem_; }
            set
            {
                problem_ = value;
            }
        }

        /// <summary>Field number for the "map_back_plan" field.</summary>
        public const int MapBackPlanFieldNumber = 2;
        private static readonly pbc::MapField<string, ActionInstance>.Codec _map_mapBackPlan_codec
            = new pbc::MapField<string, ActionInstance>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, ActionInstance.Parser), 18);
        private readonly pbc::MapField<string, ActionInstance> mapBackPlan_ = new pbc::MapField<string, ActionInstance>();
        /// <summary>
        /// The map_back_plan field is a map from the ActionInstance of the
        /// compiled problem to the original ActionInstance.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, ActionInstance> MapBackPlan
        {
            get { return mapBackPlan_; }
        }

        /// <summary>Field number for the "log_messages" field.</summary>
        public const int LogMessagesFieldNumber = 3;
        private static readonly pb::FieldCodec<LogMessage> _repeated_logMessages_codec
            = pb::FieldCodec.ForMessage(26, LogMessage.Parser);
        private readonly pbc::RepeatedField<LogMessage> logMessages_ = new pbc::RepeatedField<LogMessage>();
        /// <summary>
        /// Optional. Information given by the engine to the user.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<LogMessage> LogMessages
        {
            get { return logMessages_; }
        }

        /// <summary>Field number for the "engine" field.</summary>
        public const int EngineFieldNumber = 4;
        private Engine engine_;
        /// <summary>
        /// Synthetic description of the engine that generated this message.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Engine Engine
        {
            get { return engine_; }
            set
            {
                engine_ = value;
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other)
        {
            return Equals(other as CompilerResult);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CompilerResult other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Problem, other.Problem)) return false;
            if (!MapBackPlan.Equals(other.MapBackPlan)) return false;
            if (!logMessages_.Equals(other.logMessages_)) return false;
            if (!object.Equals(Engine, other.Engine)) return false;
            return Equals(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode()
        {
            int hash = 1;
            if (problem_ != null) hash ^= Problem.GetHashCode();
            hash ^= MapBackPlan.GetHashCode();
            hash ^= logMessages_.GetHashCode();
            if (engine_ != null) hash ^= Engine.GetHashCode();
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output)
        {
            if (problem_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Problem);
            }
            mapBackPlan_.WriteTo(output, _map_mapBackPlan_codec);
            logMessages_.WriteTo(output, _repeated_logMessages_codec);
            if (engine_ != null)
            {
                output.WriteRawTag(34);
                output.WriteMessage(Engine);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(output);
            }
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize()
        {
            int size = 0;
            if (problem_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Problem);
            }
            size += mapBackPlan_.CalculateSize(_map_mapBackPlan_codec);
            size += logMessages_.CalculateSize(_repeated_logMessages_codec);
            if (engine_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Engine);
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CompilerResult other)
        {
            if (other == null)
            {
                return;
            }
            if (other.problem_ != null)
            {
                if (problem_ == null)
                {
                    problem_ = new Problem();
                }
                Problem.MergeFrom(other.Problem);
            }
            mapBackPlan_.Add(other.mapBackPlan_);
            logMessages_.Add(other.logMessages_);
            if (other.engine_ != null)
            {
                if (engine_ == null)
                {
                    engine_ = new Engine();
                }
                Engine.MergeFrom(other.Engine);
            }
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                    case 10:
                        {
                            if (problem_ == null)
                            {
                                problem_ = new Problem();
                            }
                            input.ReadMessage(problem_);
                            break;
                        }
                    case 18:
                        {
                            mapBackPlan_.AddEntriesFrom(input, _map_mapBackPlan_codec);
                            break;
                        }
                    case 26:
                        {
                            logMessages_.AddEntriesFrom(input, _repeated_logMessages_codec);
                            break;
                        }
                    case 34:
                        {
                            if (engine_ == null)
                            {
                                engine_ = new Engine();
                            }
                            input.ReadMessage(engine_);
                            break;
                        }
                }
            }
        }

    }

    #endregion

}
#endregion Designer generated code